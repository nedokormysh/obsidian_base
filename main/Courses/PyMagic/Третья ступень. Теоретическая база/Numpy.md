
NumPy.ndarray Класс может обрабатывать многомерный массив и предоставляет больше функциональности.

## Создание массивов

### Одномерный массив

```
# преобразовываем список в массив

a = [1, 2, 3]
b = np.array(a)
```

### Двумерный массив (матрица)

```
a = [[1, 2, 3], [4, 5, 6]]
b = np.array(a)
```

### Генерация случайных чисел

```
# float

# создание рандомного элемента
print(np.random.rand(), '\n')  

# создание массива из рандомных элементов
print(np.random.rand(1, 3), '\n')

# создание матрицы из рандомных элементов
print(np.random.rand(2, 4), '\n')
```

```
# int

# создание рандомного элемента типа int
print(np.random.randint(low=0, high=10), '\n')

# создание массива из рандомных элементов типа int
print(np.random.randint(low=1, high=100, size=2), '\n')

# создание матрицы из рандомных элементов типа int
print(np.random.randint(low=-100, high=100, size=(2, 4)), '\n')
```

### Действия с элементами матрицы

Вывести элементы массива по условию
```
# условие
print(b[b > 1])
```

```
# возвращаем элементы, которые больше 3х, если меньше или равно, то заполняем нулями
np.where(b < 3, b, 0)
```

```
# np.arange - это подобие метода range
print(np.arange(1, 10, 0.24))
```

### Виды матриц

```
print('Матрица 3 на 5 состоящая из нулей')
np.zeros(shape=(3, 5))
```
```
print('Матрица 3 на 5 состоящая из единиц')
np.ones(shape=(3, 5))
```
```
print('Матрица 3 на 3 единичная')
np.eye(N=3)
```
```
print('Диагональная матрица')
k = [2, 3, 6, 8, 9, 10, -1]
np.diag(v=k)
```

## Операции над матрицами

```
# изменение размера матрицы без замены элементов
k.reshape(2, 3)
```

```
print('Умножение элементов матрицы')

print(b * 2, '\n')

  

print('Сложение матриц')

print(b + b * 2, '\n')

  

'''

Если a и b являются двумерными массивами (матрицами), то выполняется

матричное умножение и np.dot(a, b) становится эквивалентна функции

np.matmul(a, b) или команде a@b, которые являются более предпочтительными

'''

print('Скалярное умножение матриц')

print(np.dot(b, k), '\n')


print('Векторное умножение матриц')

print(np.cross(b, k.reshape(2, 3)), '\n')
```

```
print('Исходная матрица b')
print(b, '\n')  

print('Транспонированная b: ij -> ji')
print(b.T, '\n')  

print('Матрица c - 2 на 2')
c = np.arange(2, 6, 1).reshape(2, 2)
print(c, '\n')
 

print('Обратная матрица на основании матрицы - с')

print(np.linalg.inv(c))
```

## Определитель и ранг матрицы

```
# Определитель
print(np.linalg.det(c))
```

```
# манхэттенская норма вектора a
print(f'манхэттенская норма вектора a: {np.linalg.norm(a, ord=1)}')
```

```
# евклидова норма вектора a
print(f'евклидова норма вектора a: {np.linalg.norm(a, ord=2)}')
```

```
# угол между векторами (cos similarity) пример из ДЗ  

a = np.array([2, 4, 5]) # 1 user
b = np.array([100, 4, 5]) # 2 user  

# 1 способ по формуле
similarity = np.dot(a, b) / (np.linalg.norm(a, ord=2) * np.linalg.norm(b, ord=2))  

print(f'Косинус угла между a и b: {similarity:.3f}')
print(f'Угол между a и b: {np.arccos(similarity):.2f}')
```

```
# добавление нового измерения в массив  (используется для индексирования массивов)
a[np.newaxis, :]
```

```
# эквивалентно
a.reshape((1, 3))
```

## Сингулярное разложение матриц

```
U, S, Vt = np.linalg.svd(c) 

# Ортогональная матрица
print(U, '\n')  

# Диагональная матрица

print(np.diag(S), '\n')  

# V - Ортогональная матрица (уже транспонированная!)

print(Vt, '\n')
```