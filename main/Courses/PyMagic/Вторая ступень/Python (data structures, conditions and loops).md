# Структуры данных

В языке программирования Python существует четыре типа структуры данных:
  
- Список - это упорядоченное и изменяемое множество. Позволяет дублировать объекты.
- Кортеж - это неизменяемый список, также он упорядочен. Позволяет дублировать объекты.
- Множество - это неупорядоченное и неиндексированное множество. Нет повторяющихся объектов.
- Словарь - это сборник, упорядоченный и изменяемый. Нет повторяющихся объектов.

**Упорядоченные наборы данных** - это такие наборы, которые находятся в том же порядке, в котором они указаны.

### list()

C помощью скобок создается список. После этого выводится переменная с присвоенным ей пустым списком. Выводится «[]», что указывает пусть и на пустой, но список. Также можно использовать метод list()

Мы можем обращаться к различным элементам листа через индекс, а также выводить набор значений от и до
 ```my_list = ['string', 8.5, 9, 10]
print(f"{my_list[0] = }")
print(f"{my_list[3] = }")''

--my_list[0] = 'string'
--my_list[3] = 10
####
 my_list[start:stop:step]
 с 1 по 3 элемент (отсчет от 0)
--my_list[1:3]
 ```
 

```
# переворачиваем список
my_list[::-1]
```

Мы можем присваивать значения отдельным элементам list

Важно еще отметить функцию len(), она возвращает длину (количество элементов) в объекте. Аргумент может быть последовательностью, такой как строка, байты, кортеж, список или диапазон или коллекцией (такой как словарь, множество или неизменяемое множество).

- Можем добавлять элемент в конец списка
```
my_list.append('bar')
```

- Удалить элемент с конца списка, где можем присвоить удаленный элемент новой переменной
```
# pop - удаление по индексу

value_del = my_list.pop()
```

- Удаление элемента по значению
```
my_list.remove(9)
```

### tuple()

**Кортеж** – это (неизменяемый) упорядоченный список значений. Кортеж во многом похож на список; одно из наиболее важных отличий заключается в том, что кортежи можно использовать в качестве ключей в словарях и в качестве элементов наборов, в то время как **списки не могут использоваться в качестве ключа.**
Мы можем обратиться к данным кортежа по индексу и найти значение

А вот удалить значение (или изменить), уже не сможем, выведется ошибка

```
my_tuple[0] = 2

del my_tuple[0]
```
Будет ошибка

Аналогично списку, в кортеже поддерживаются слайсы

### set()

**set()** – множество.

Элементы множества неупорядочены, изменяемы set() и неизменяемые flozenset(), не допускают повторяющихся значений.
Нельзя обратиться к элементу по индексу
Нельзя изменять элементы по индексам
Нельзя делать слайсы набора
Проверка на отсутствие элемента
```
x in my_set
```

Удаляет указанный элемент из множества, если он там присутствует
```
my_set.discard(8.8)
```

Удалить (но нельзя удалить отсутствующий элемент)
```
my_set.remove(0)
```

Объединение множеств

```
my_set | {1, 2}
```

Объекты, в которых множества не пересекаются (разность)
```
my_set ^ {1,2}
```
Объекты, которые содержатся и в одном, и в другом множестве
```
my_set & {1, 2}
```

### dict()

Словари используются для хранения значений данных в парах ключ: значение.

**Словарь (еще называют хэш-таблицы)** - это неупорядоченный сборник, изменяемый и не допускающий дубликатов. Словари написаны в фигурных скобках и имеют ключи и значения.

Ключи - неизменяемые типы
```
my_dict = {
    "key1": ["string"],
    "key2": 10,
    1: "string2",
    2.9: 11.5
}  

print(f"{my_dict = }, {type(my_dict)}")
```

Чтобы удалить элемент из словаря необходимо использовать del / pop

```
del my_dict['key1']
my_dict.pop('key1', "Такого значения нет")
```

## Условные операторы

Python поддерживает обычные логические условия из математики:
 

- Равно: a == b
- Не равно: a! = B
- Меньше чем: a <b

- Меньше или равно: a <= b
- Больше чем: a> b
- Больше или равно: a> = b
  

Довольно часто логические выражения применяются в условных операторах в python. Условные операторы необходимы для того, чтобы выполнить необходимое дейсвие по заданному условию.

  

if (если - условие) действие (если True)

else (то) действие (если False) 

**Нужно запомнить!**

1. if-else -  ЭТО ОДИН ОПЕРАТОР! Сокращенно может записываться elif
2. После слова else НИКОГДА УСЛОВИЕ НЕ СТАВИТСЯ (условие ставиться только после слова if или elif).
     Блок "иначе" выполняется тогда, когда основное условие, указанное после слова if  - ложно, т.е. не выполняется.
3. Операторы, которые необходимо выполнить в каждой ветке (if или else), записываются с одинаковым сдвигом в 4 пробела. СДВИГИ ОБЯЗАТЕЛЬНЫ!

## Циклы

В Python есть две команды для использования цикла:

- while
- for

```
# пока count меньше n выполняй

count = 0
n = 5 

while count < n:
    count += 1
    print(count)
```
```
for i in [2, 4, 5]:
    print(i)
```
### range()

В качестве множества значений для перебора в for мы можем передавать списки, одномерные массивы, или как в примере функцию range().  

Функция range может также принимать не один, а три параметра. Вызов range(a, b, c).  

- a - начальное значение
- b - конечное значение (не включительно)
- с - шаг (по умолчанию с=1)

Если же a≥b, то цикл не будет выполнен.

```
# Массив значений от 0 до 10 (не включительно)

print(range(n))

print(list(range(n)))
```
```
[x*2 for x in range(1, 10)]
```

## break

Оператор break досрочно прерывает цикл

```
# Оператор break досрочно прерывает цикл

  

lst = []
 

for i in range(1, 10):

    print(f'i = {i}')
    if 2 < i < 5:
        print(f'break and i = {i}\n')
        break
    else:
        print(f'append and i = {i}\n')
        lst.append(i) 

print(lst)
i = 1
append and i = 1
i = 2
append and i = 2
i = 3
break and i = 3 [1, 2]
```
Если циклов или условий несколько, то он прервет только то условие/цикл, в котором находился
```
lst = []

lst2 = []

  

for i in range(3, 5):
    for j in range(1, 10):
        print(f'{i = }, {j = }\n')
        if j > 5:
            print(f'append and {i = }, {j = }')
            lst2.append(i)
        break
    lst.append(i)

print(lst)
print(lst2)

###
i = 3, j = 1
i = 4, j = 1
[3, 4]
[]
```

## for/while-else

**else** помимо конструкции if-else можно еще использовать для циклом for/while. else в этих случаях будет проверять, был ли произведен выход из цикла при помощи **break**, либо выход из цикла был естественным. **Если выход был естественным**, то выполняется все то, что находится **внутри блока** else.

```
result = []

  

for i in range(1, 15):
    if i == 14:
        break

# заходим в блок, если был выход из цикла

else:
    result.append(i)

# что будет?

result
[]
```

```
result = []

  

for i in range(1, 15):

    if i == 5:

        print(f"{i = }")

# заходим в блок, если был выход из цикла

else:

    result.append(i)

# что будет?

result

i = 5
[14]
```

## continue

Оператор continue начинает следующий проход цикла, минуя оставшееся тело цикла (for или while)
```
i = 0

  

while i < 10:

    i += 1

    if i == 5:

        print(f'continue and i: {i}')

        continue

    print(f'Вывод: {i}')


###
Вывод: 1
Вывод: 2
Вывод: 3
Вывод: 4
continue and i: 5
Вывод: 6
Вывод: 7
Вывод: 8
Вывод: 9
Вывод: 10
```

[[Вторая ступень. Основы Python и SQL._Content]]