
# GROUP BY

Для группировки данных по какому-либо полю и дальнейшей агрегации значений (например, группировка по имени и агрегация поля цена), применяют функцию GROUP BY

```
SELECT CustomerID, FirstName, sum(Price) as sum_price
FROM Orders
GROUP BY CustomerID, FirstName
```
1) Посчитаем кол-во мужчин и женщин
```
SELECT gender, count(gender) as cnt_gender
from emp_test as e
group by gender
```
2) Посчитаем кол-во мужчин и женщин в разрезе title
```
SELECT title, gender, count(gender) as cnt_empl
from emp_test as e
group by title, gender
```
3) Найдем кол-во уникальных сотрудников для каждой должности из таблицы employees. Мы сгруппировали по полю title (тут будут выведены только уникальные значения в этой колонке) и далее если полей несколько в группе, то они объединяются (суммируются значения, находится среднее и так далее)
```
SELECT title, count(distinct emp_no) as cnt_emp
from employees as e
group by title;
```
4) как мне подсчитать максимальное значение id сотрудника в каждом департаменте (dept_emp)?
```
select dept_name, max(emp_no) as max_emp
from dept_emp
group by dept_name
```
5) Найти максимальную зарплату менеджеров в каждом из департаментов.
Для примера также применили cast(d.emp_no as int) - где **cast** это переводит в заданный тип данных

```
SELECT distinct d.dept_name, max(s.salary) as max_salary
from salaries s
inner join dept_manager d on cast(d.emp_no as int) = s.emp_no
group by d.dept_name;
```
# Having 

Для вывода строк по условию при применении ГРУППИРОВКИ, используют HAVING.
Например, мы сгруппировали клиентов по их id и имени, в качестве агрегата использовали общую сумму их покупок. Далее нам нужно вывести только тех, чья общая сумма больше 1000.

```
Select CustomersID, FirstName, sum(Price) as sum_price
FROM Orders
Group By CustomersID, FirstName
Having sum(Price) > 1000
```
1) Найти максимальную зарплату менеджеров в каждом из департаментов, где максимальная зарплата должна быть больше 50000
```
SELECT distinct d.dept_name, max(s.salary) as max_salary
from salaries s
inner join dept_manager d on d.emp_no = s.emp_no
group by d.dept_name
```

having max(s.salary)>50000
2) Можем добавить еще одно условие к предыдущему заданию: отсортировать максимальные зарплаты в порядке возрастания
```
SELECT distinct d.dept_name, max(s.salary)
from salaries s
inner join dept_manager d on d.emp_no = s.emp_no
group by d.dept_name
having max(s.salary)>50000
order by s.salary
```
# Оконные функции

Оконные функции отлично помогают в вычислении над заданным набором строк:
объединение в группы по определенному признаку, например идентификатору.
Результаты мы можем добавлять к исходной выборке. Этот функционал очень полезен для построения аналитических отчетов, расчета скользящего среднего и нарастающих итогов, а также для расчетов различных моделей атрибуции. Окно определяется с помощью обязательной инструкции OVER()

```
Select

over(
partition by
order by
rows
)
```

## Виды оконных функций:

• Агрегатные
• Ранжирующие
• Функции смещения
• Аналитические
Рассмотрим на примере агрегатных функции – это функции, которые выполняют на наборе данных арифметические вычисления и возвращают итоговое значение.
• SUM – возвращает сумму значений в столбце;
• COUNT— вычисляет количество значений в столбце (значения NULL не учитываются);
• AVG— среднее значение в столбце;
• MAX— максимальное значение в столбце;
• MIN—минимальное значение в столбце.

Посчитаем общее число проданных товаров и запишем все в новую колонку. Заметим, что во всех строках количество совпадает, так как мы еще не применяли группировку PARTITION BY

```
Select *
	sum(counts) over() as 'sum counts'
From Orders
```

Сделаем аналогичное действие, но уже в рамках столбца FirstName, использовав PARTITION
BY, который помогает группировать по заданному полю и записывается внутри скобок в OVER:

```
Select *
	sum(counts) over(partition by firstName) as 'sum counts'
From Orders
```

Дополнительно сделаем сортировку при помощи ORDER BY по полю Price. Когда мы добавили ORDER BY, то таким образом мы указали, что хотим видеть сумму не всех значений в окне, а для каждого значения Counts сумму со всеми предыдущими в группе значениями поля Id. То есть мы посчитали нарастающий итог. Если значения в Id будут одинаковы, то и нарастающая сумма в соответствующих строках тоже

Select *
	sum(counts) over(partition by firstName Order by Id) as 'sum counts'
From Orders


ROWS или RANGE позволяют ограничить строки в окне, указывая фиксированное количество строк, предшествующих или следующих за текущей, также они всегда используются вместе с ORDER BY.
Попробуем просуммировать текущую строку с двумя следующими внутри группы FirstName.
Последняя строка в группе останется без изменений, так как далее уже нет строк, отвечающих условию.

Select *
	sum(counts) over(partition by firstName Order by Id) as 'sum1',
	sum(counts) over(partition by firstName Order by Id ROWS BETWEEN
Current Row and 2 following as 'sum2'
From Orders

В выражении для ограничения строк ROWS или RANGE также можно
использовать следующие ключевые слова:
• UNBOUNDED PRECEDING— указывает, что окно начинается с первой строки группы
• UNBOUNDED FOLLOWING – с помощью данной инструкции можно указать, что окно
заканчивается на последней строке группы
• CURRENT ROW– инструкция указывает, что окно начинается или заканчивается на текущей
строке
• BETWEEN «граница окна» AND «граница окна»— указывает нижнюю и верхнюю границу
окна;
• «Значение» PRECEDING – определяет число строк перед текущей строкой (не допускается в
предложении RANGE)
• «Значение» FOLLOWING— определяет число строк после текущей строки (не допускается в
предложении RANGE)

# Ранжирующие функции

Ранжирующие функции – это функции, которые ранжируют (нумеруют) значение для каждой строки в окне. Например, их можно использовать для того, чтобы присвоить порядковый номер строке или составить рейтинг.
• ROW_NUMBER – возвращает номер строки и используется для нумерации;
• RANK—возвращает ранг каждой строки. В данном случае значения уже анализируются и, в случае нахождения одинаковых, возвращает одинаковый ранг с пропуском следующего значения;
• DENSE_RANK —возвращает ранг каждой строки. Но в отличие от функции RANK, она для одинаковых значений возвращает ранг, не пропуская следующий;
• NTILE – это функция, которая позволяет определить к какой группе относится текущая строка. Количество групп задается в скобках.

Очень часто вы можете встретить ROW_NUMBER как в задачах на собеседованиях, так и в
реальной жизни, функция отлично подходит для нумерации (например, когда в таблице
содержится информация о клиенте в двух строках, со старой и новой записью).

SELECT *
	row_number() over (partition by firstName order by id) as 'rn'
From orders

Функции смещения – это функции, которые позволяют перемещаться и обращаться к разным
строкам в окне, относительно текущей строки, а также обращаться к значениям в начале или в
конце окна.
• LAG или LEAD – функция LAG обращается к данным из предыдущей строки окна, а LEAD к
данным из следующей строки. Имеет три параметра: столбец, значение которого
необходимо вернуть, количество строк для смещения (по умолчанию 1), значение, которое
необходимо вернуть если после смещения возвращается значение NULL;
• FIRST_VALUE или LAST_VALUE— с помощью функции можно получить первое и последнее
значение в окне. В качестве параметра принимает столбец, значение которого необходимо
вернуть.

LAG – функция обращается к данным из предыдущей строки окна, LEAD – к данным из следующей строки.