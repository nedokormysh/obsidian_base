
# GROUP BY

Для группировки данных по какому-либо полю и дальнейшей агрегации значений (например, группировка по имени и агрегация поля цена), применяют функцию GROUP BY

```
SELECT CustomerID, FirstName, sum(Price) as sum_price
FROM Orders
GROUP BY CustomerID, FirstName
```
1) Посчитаем кол-во мужчин и женщин
```
SELECT gender, count(gender) as cnt_gender
from emp_test as e
group by gender
```
2) Посчитаем кол-во мужчин и женщин в разрезе title
```
SELECT title, gender, count(gender) as cnt_empl
from emp_test as e
group by title, gender
```
3) Найдем кол-во уникальных сотрудников для каждой должности из таблицы employees. Мы сгруппировали по полю title (тут будут выведены только уникальные значения в этой колонке) и далее если полей несколько в группе, то они объединяются (суммируются значения, находится среднее и так далее)
```
SELECT title, count(distinct emp_no) as cnt_emp
from employees as e
group by title;
```
4) как мне подсчитать максимальное значение id сотрудника в каждом департаменте (dept_emp)?
```
select dept_name, max(emp_no) as max_emp
from dept_emp
group by dept_name
```
5) Найти максимальную зарплату менеджеров в каждом из департаментов.
Для примера также применили cast(d.emp_no as int) - где **cast** это переводит в заданный тип данных

```
SELECT distinct d.dept_name, max(s.salary) as max_salary
from salaries s
inner join dept_manager d on cast(d.emp_no as int) = s.emp_no
group by d.dept_name;
```
# Having 

Для вывода строк по условию при применении ГРУППИРОВКИ, используют HAVING.
Например, мы сгруппировали клиентов по их id и имени, в качестве агрегата использовали общую сумму их покупок. Далее нам нужно вывести только тех, чья общая сумма больше 1000.

```
Select CustomersID, FirstName, sum(Price) as sum_price
FROM Orders
Group By CustomersID, FirstName
Having sum(Price) > 1000
```
1) Найти максимальную зарплату менеджеров в каждом из департаментов, где максимальная зарплата должна быть больше 50000
```
SELECT distinct d.dept_name, max(s.salary) as max_salary
from salaries s
inner join dept_manager d on d.emp_no = s.emp_no
group by d.dept_name
```

having max(s.salary)>50000
2) Можем добавить еще одно условие к предыдущему заданию: отсортировать максимальные зарплаты в порядке возрастания
```
SELECT distinct d.dept_name, max(s.salary)
from salaries s
inner join dept_manager d on d.emp_no = s.emp_no
group by d.dept_name
having max(s.salary)>50000
order by s.salary
```
# Оконные функции

Оконные функции отлично помогают в вычислении над заданным набором строк:
объединение в группы по определенному признаку, например идентификатору.
Результаты мы можем добавлять к исходной выборке. Этот функционал очень полезен для построения аналитических отчетов, расчета скользящего среднего и нарастающих итогов, а также для расчетов различных моделей атрибуции. Окно определяется с помощью обязательной инструкции OVER()

```
Select

over(
partition by
order by
rows
)
```

## Виды оконных функций:

• Агрегатные
• Ранжирующие
• Функции смещения
• Аналитические
Рассмотрим на примере агрегатных функции – это функции, которые выполняют на наборе данных арифметические вычисления и возвращают итоговое значение.
• SUM – возвращает сумму значений в столбце;
• COUNT— вычисляет количество значений в столбце (значения NULL не учитываются);
• AVG— среднее значение в столбце;
• MAX— максимальное значение в столбце;
• MIN—минимальное значение в столбце.

Посчитаем общее число проданных товаров и запишем все в новую колонку. Заметим, что во всех строках количество совпадает, так как мы еще не применяли группировку PARTITION BY

```
Select *
	sum(counts) over() as 'sum counts'
From Orders
```

Сделаем аналогичное действие, но уже в рамках столбца FirstName, использовав PARTITION
BY, который помогает группировать по заданному полю и записывается внутри скобок в OVER:

```
Select *
	sum(counts) over(partition by firstName) as 'sum counts'
From Orders
```

Дополнительно сделаем сортировку при помощи ORDER BY по полю Price. Когда мы добавили ORDER BY, то таким образом мы указали, что хотим видеть сумму не всех значений в окне, а для каждого значения Counts сумму со всеми предыдущими в группе значениями поля Id. То есть мы посчитали нарастающий итог. Если значения в Id будут одинаковы, то и нарастающая сумма в соответствующих строках тоже

Select *
	sum(counts) over(partition by firstName Order by Id) as 'sum counts'
From Orders


ROWS или RANGE позволяют ограничить строки в окне, указывая фиксированное количество строк, предшествующих или следующих за текущей, также они всегда используются вместе с ORDER BY.
Попробуем просуммировать текущую строку с двумя следующими внутри группы FirstName.
Последняя строка в группе останется без изменений, так как далее уже нет строк, отвечающих условию.

Select *
	sum(counts) over(partition by firstName Order by Id) as 'sum1',
	sum(counts) over(partition by firstName Order by Id ROWS BETWEEN
Current Row and 2 following as 'sum2'
From Orders

В выражении для ограничения строк ROWS или RANGE также можно
использовать следующие ключевые слова:
• UNBOUNDED PRECEDING— указывает, что окно начинается с первой строки группы
• UNBOUNDED FOLLOWING – с помощью данной инструкции можно указать, что окно
заканчивается на последней строке группы
• CURRENT ROW– инструкция указывает, что окно начинается или заканчивается на текущей
строке
• BETWEEN «граница окна» AND «граница окна»— указывает нижнюю и верхнюю границу
окна;
• «Значение» PRECEDING – определяет число строк перед текущей строкой (не допускается в
предложении RANGE)
• «Значение» FOLLOWING— определяет число строк после текущей строки (не допускается в
предложении RANGE)

# Ранжирующие функции

Ранжирующие функции – это функции, которые ранжируют (нумеруют) значение для каждой строки в окне. Например, их можно использовать для того, чтобы присвоить порядковый номер строке или составить рейтинг.
• ROW_NUMBER – возвращает номер строки и используется для нумерации;
1) Пронумеруем сотрудников в порядке их устройства на ту или иную должность внутри компании, так сможем посмотреть, если у него было больше чем 1 место работы, то какое из них было первым

```
select *
from dept_emp
where emp_no = 10010
limit 3;
```

```
select *,
    row_number() over(partition by emp_no order by from_date) as rn
from dept_emp
where emp_no = 10010
limit 10
```
• RANK—возвращает ранг каждой строки. В данном случае значения уже анализируются и, в случае нахождения одинаковых, возвращает одинаковый ранг с пропуском следующего значения;
• DENSE_RANK —возвращает ранг каждой строки. Но в отличие от функции RANK, она для одинаковых значений возвращает ранг, не пропуская следующий;
1) Пронумеруем зарплаты сотрудников внутри департамента, если зарплаты схожи, то пусть будет один и тот же ранг
```
select s.emp_no, s.salary, dept_name,
    dense_rank() over(partition by dept_name order by s.salary) as rn
from salaries s
inner join dept_manager d on d.emp_no = s.emp_no
where dept_name = 'Customer Service'
order by s.salary
limit 15
```
• NTILE – это функция, которая позволяет определить к какой группе относится текущая строка. Количество групп задается в скобках.

Очень часто вы можете встретить ROW_NUMBER как в задачах на собеседованиях, так и в
реальной жизни, функция отлично подходит для нумерации (например, когда в таблице
содержится информация о клиенте в двух строках, со старой и новой записью).

```
SELECT *
	row_number() over (partition by firstName order by id) as 'rn'
From orders
```

Функции смещения – это функции, которые позволяют перемещаться и обращаться к разным
строкам в окне, относительно текущей строки, а также обращаться к значениям в начале или вконце окна.
• LAG или LEAD – функция LAG обращается к данным из предыдущей строки окна, а LEAD к
данным из следующей строки. Имеет три параметра: столбец, значение которого
необходимо вернуть, количество строк для смещения (по умолчанию 1), значение, которое
необходимо вернуть если после смещения возвращается значение NULL;
1) Проставим в отдельном столбце дату начало работы на предыдущем месте. Заодно попробуем потренироваться в создании VIEW (представление - виртуальная таблица)

**Представление (VIEW)** — объект базы данных, являющийся результатом выполнения запроса к базе данных, определенного с помощью оператора SELECT, в момент обращения к представлению.

```
create view uniq_empl
as
select emp_no, from_date, to_date,
    LAG(from_date) over(partition by emp_no order by from_date) as date_prev
    from dept_emp;
COMMIT;
```
• FIRST_VALUE или LAST_VALUE— с помощью функции можно получить первое и последнее
значение в окне. В качестве параметра принимает столбец, значение которого необходимо
вернуть.

LAG – функция обращается к данным из предыдущей строки окна, LEAD – к данным из следующей строки.

Если информации о предыдущей строке в разрезе сотрудника нет, то будет пустое значение ''

# WITH

**Common Table Expression (CTE) или обобщенное табличное выражение (OTB)** – это временные результирующие наборы (т.е. результаты выполнения SQL запроса), которые не сохраняются в базе данных в виде объектов, но к ним можно обращаться.

Использование WITH удобно, в особенности, если мы сравниваем с использованием этого оператора с подзапросами, так как они повышают читаемость кода. Также нет необходимости создавать новую таблицу и засорять БД.

Для этого воспользуемся оператором WITH назовем временную таблицу и в скобках укажем запрос, который бы создал такую таблицу.

```
with rn_salary as (
    select s.emp_no, s.salary, dept_name,
    dense_rank() over(partition by dept_name order by s.salary) as rn
    from salaries s
    inner join dept_manager d on d.emp_no = s.emp_no
    order by s.salary desc
)
select *
from rn_salary
where rn = 2
limit 20
```

# CASE

```
select e.*, d.to_date,
    case when (e.title = 'Manager' and d.to_date = '9999-01-01') then 1 else 0 end as flg_curr_manager
from employees e
inner join dept_emp d on e.emp_no = d.emp_no
where e.title in ('Manager', 'Senior Engineer')
order by e.title
limit 20, 10
```
# UNION

**UNION** - применяется для объединения двух наборов строк, возвращаемых SQL-запросами. Оба запроса должны возвращать одинаковое число столбцов, и столбцы с одинаковым порядковым номером должны иметь совместимые типы данных. Результат получает структуру (названия и типы столбцов) первого (левого) запроса, то есть операция не является симметричной.

Пример, как можно убрать дубли в таблице. Для этого создадим тестовую таблицу salary_test так, чтобы были повторяющиеся значения
При помощи UNION объеденим строки таблиц и получим только уникальные значения без дублей

```
select *
from salary_test
UNION
select *
from salary_test
```

[[Вторая ступень. Основы Python и SQL._Content]]