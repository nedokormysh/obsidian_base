
# Классы и объекты

**Объектно-ориентированное программирование (ООП)** — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определённого класса, а классы образуют иерархию наследования.
Python соответствует принципам объектно-ориентированного программирования. В python всё является объектами - и строки, и списки, и словари, и всё остальное.
Но возможности ООП в python этим не ограничены. Программист может написать свой тип данных (класс), определить в нём свои методы.
Это не является обязательным - мы можем пользоваться только встроенными объектами. Однако ООП полезно при долгосрочной разработке программы несколькими людьми, так как упрощает понимание кода.  

**Какие есть преимущества ООП?**  

- Программа разбивается на объекты. Каждый объект отвечает за собственные данные и их обработку. В результате код становится читабельней и проще
- Ускоряется процесс написания программы, так как сначала создаете высокоуровневую структуру классов и базовый функционал, а далее переходите к их подробной реализации
- Не нужно дублицировать код. Есть возможность унаследовать дочернему классу функционал от родительского класса  

**Основные определения:**  

> **Класс** - это некий шаблон для создания объектов, описывает свойства и поведение, которыми могут обладать объекты  

> **Свойства класса (поля)** - это характеристики объекта класса (например: цвет, длина)  

> **Методы класса** - это функции, с помощью которых можно оперировать данными класса (например: посчитать производную)  

> **Объект (экземпляр класса)** — некоторая сущность, реализация какого-то класса, обладающая уже определённым состоянием и поведением  

> **Конструктор** - Создает экземпляр(объект) класса. Вызывается первым  

> **Деструктор** - Вызывается при удалении объекта сборщиком мусора  

> **ВАЖНО!** Название классов начинаются с заглавной буквы. Например: MyClass, CatDog

```
# Также доступны встроенные (служебные) атрибуты

# Документация класса

print(r.__doc__)
  

# Словарь, в котором хранится пространство имен класса

print(r.__dict__) 

# Список атрибутов класса
print(r.__dir__())

-----------
None {'x': 1} ['x', '__module__', '__dict__', '__weakref__', '__doc__', '__repr__', '__hash__', '__str__', '__getattribute__', '__setattr__', '__delattr__', '__lt__', '__le__', '__eq__', '__ne__', '__gt__', '__ge__', '__init__', '__new__', '__reduce_ex__', '__reduce__', '__subclasshook__', '__init_subclass__', '__format__', '__sizeof__', '__dir__', '__class__']
```

## Инициализация

В классе мы можем инициализировать объекты, а при помощи методов, производить над этими объектами действия.  

> **self** - это ссылка на конкретный экземпляр класса. При этом, self не зарезервировано как имя в python,  является лишь договоренностью  

> **cls** - это ссылка на класс, для которого запрошено конструирование объекта  

> **self** – сcылка на текущий экземпляр класса, он необходим для получения доступов к различным методам и переменным объявленным  в классе.  

> **метод _ _new_ _()** - конструктор, вызывается при создании класса.  

> **метод _ _init_ _()** - инициализатор, принимает созданный конструктором объект, позволяет инициализировать, то есть объявить ваши переменные, которые вы сможете потом повсеместно использовать в вашем классе.  

Каждый раз, когда создается новый объект Rectangle, метод _ _init_ _() устанавливает начальное состояние, присваивая свойствам значения (инициализирует каждый новый экземпляр класса)

  В _ _init_ _ также указан self, он необходим, чтобы вы закрепили в самом начале адресацию на ваши переменные.

**ВАЖНО:** self - это незарезервированное имя, просто как соглашение между программистами

> При вызове super()._ _ new _ _(cls) мы получаем доступ к методу object._ _ new _ _() родительского класса **object**, который является базовой реализацией метода .__new__() для всех классов Python

> На практике вы используете метод _ _ new _ _(), когда хотите настроить объект в момент времени создания экземпляра. 

> obejct - является базовым классом для всех классов Python по умолчанию

```
class Rectangle:

    # это атрибуты класса
    # статические поля (свойства или переменные класса)
    COLOR = 'green'

    # конструктор
    # *args, **kwargs - для гибкости метода
    def __new__(cls, *args, **kwargs):
        print(f'Design: {args} | {kwargs}')
        print(f'Creating a new {cls.__name__} object...')
        obj = super().__new__(cls)
        # это атрибуты экземпляра класса
        obj.new_attribute = 'добавлено'
        return obj

  

    # инициализатор
    def __init__(self, width: int, length: int) -> None:
        print(f'Initializing the Rectangle object...\n')
        # это атрибуты экземпляра класса
        # динамические поля (свойства или переменные экземпляра класса)
        self.width = width
        self.length = length

  
    # метод экземпляра класса (также атрибут)
    def perimeter(self) -> int:
        return (self.width + self.length) * 2
        
    # метод экземпляра класса (также атрибут)
    def show_perimeter(self) -> None:

        print(f"Периметр прямоугольника: {self.perimeter()}")

  


r = Rectangle(width=5, length=2)

print(f"Статическая переменная: {r.COLOR = }\n")

print(f"Динамическая переменная: {r.width = }\n")

r.show_perimeter()

print(r.new_attribute)
------------
Design: () | {'width': 5, 'length': 2}
Creating a new Rectangle object...
Initializing the Rectangle object...
Статическая переменная: r.COLOR = 'green'
Динамическая переменная: r.width = 5
Периметр прямоугольника: 14 добавлено
```

В конструкторе класса мы можем добавить какую-нибудь проверку при создании нового объекта класса. Например, проверку на неотрицательность передаваемых параметров.

Если вы хотите использовать какие-то конкретные значения при инициализации, то можно прописать переменную с ее значением в **init** с указанием self:

## Методы 

### Статичный метод

> **@staticmethod** — используется для создания метода, который ничего не знает о классе или экземпляре, через который он был вызван. Он просто получает переданные аргументы, без неявного первого аргумента, и его определение неизменяемо через наследование.

  Проще говоря, @staticmethod — это вроде обычной функции, определенной внутри класса, которая не имеет доступа к экземпляру, поэтому ее можно вызывать без создания экземпляра класса.
```
# для статического можно ничего не передавать

    # либо передавать параметры. НО НЕ ссылку self на объекты класса!!
    @staticmethod
    def perimeter(x: int, y: int) -> int:
        return (x + y) * 2

# статический метод я могу вызвать, не создавая экземпляр класса
Rectangle.perimeter(2, 4)
```

### Метод класса

> **@classmethod** — это декоторатор, определяет метод класса, который получает класс в качестве неявного первого аргумента, точно так же, как обычный метод экземпляра получает экземпляр. Это означает, что вы можете использовать класс и его свойства внутри этого метода, а не конкретного экземпляра.

> classmethod — это метод, который **привязан к классу, а не к экземпляру класса**

Проще говоря, **classmethod** — это обычный метод класса, имеющий доступ ко всем атрибутам класса, через который он был вызван.

```
class Rectangle:

    VOLUME = 24

    def __init__(self, width: int, length: int) -> None:

        self.width = width
        self.length = length
    # метод класса работает с атрибутами класса, но не c экзепляром
    # пусть нам хочется из объема параллелипипида,
    # его ширины и высоты -> получить ширину и длину

    @classmethod
    def change_params(cls, width, height):
        # вернет экземпляр класса, так как используем cls
        # cls - указывает не на объект, а на сам класс
        print(f"{cls.VOLUME = }")
        return cls(width, (cls.VOLUME / (width * height)))

    def perimeter(self) -> int:
        return (self.width + self.length) * 2
          
    def show_perimeter(self) -> None:
        print(f"Периметр прямоугольника: {self.perimeter()}")
  
  
r = Rectangle(1, 2)

r.show_perimeter()
------
Периметр прямоугольника: 6
```

```
rec_ex = Rectangle.change_params(width=3, height=4)

# тогда length = 2
# и по идее perimeter = (2 + 3)*2 = 10
rec_ex.show_perimeter()
------
cls.VOLUME = 24
Периметр прямоугольника: 10.0
```

# Принципы ООП

## Абстракция

**Абстракция** — это выделение основных, наиболее значимых характеристик объекта и игнорирование второстепенных  

**Пример:**
Предположим какой-то завод спроектировал и сконструировал новый автомобиль и выпустил его на продажу. Вам понравился этот автомобиль и вы решили его купить. Вам не важно какие провода где расположены, какие механизмы и как они взаимосвязаны внутри "под капотом", вам важно, чтобы при нажатии например на кнопку "Start" ваш автомобиль заводился, что там внутри и как это работает, вам не интересно, вы конечный потребитель.
  
> По сути мы **описываем наш объект** при помощи набора свойств (характеристик) и действий (методов), тем самым производя определенную абстракцию нашего объекта.

## Инкапсуляция

  

**Инкапсуляция** – это свойство системы, позволяющее объединить данные и методы, работающие с ними в классе и **скрыть** детали реализации от пользователя.  

Инкапсуляция в Python работает лишь на уровне соглашения между программистами о том, какие атрибуты являются общедоступными, а какие — внутренними.  

> **Одиночное подчеркивание** в начале имени атрибута говорит о том, что переменная или метод не предназначен для использования вне методов класса, однако атрибут доступен по этому имени (**protected**)  

> **Двойное подчеркивание** в начале имени атрибута даёт большую защиту: атрибут становится недоступным по этому имени, но к нему есть доступ только внутри самого класса (**private**)

Однако полностью это не защищает, так как атрибут всё равно остаётся доступным под именем _ИмяКласса__ИмяАтрибута:

## Наследование

  **Наследование** – это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым или родительским. Новый класс – потомком, наследником или производным классом.
  
Давайте скажем, что **Rectangle** – это будет **базовый (родительский) класс**, также мы хотим создать **дочерний/ие класс/ы Square**, который сможет наследовать не только параметры, которые мы инициализировали в родительском, но и методы.

Дополнительный материал про **множественное наследование**

```
class Rectangle:

    def __init__(self, width: int, length: int) -> None:
        self.width = width
        self.length = length
        self.color = 'green'

    def perimeter(self) -> int:
        return (self.width + self.length) * 2 

    def show_perimeter(self) -> None:
        print(f"Периметр прямоугольника: {self.perimeter()}")  

# квадрат - это равносторонний прямоугольник
# куб - это правильный шестигранник, все грани - квадраты.

class Cube(Rectangle):

    # Добавляем новый параметр height

    def __init__(self, width: int, length: int, height: int):
        # вызываем метод инициализации из родительского класса
        # чтобы не потерять атрибуты
        super().__init__(width, length)
        self.height = height
    # добавим новый метод для вычисления объема куба

    def volume(self) -> int:
            return self.height * self.width * self.length
```
Перегрузим (заменим родительский метод init) инициализатор класса потомка

## Полиморфизм

  
> Мы могли заметить, что в родительском классе изначально было заложено, что при выводе периметра фигуры, выводится именно слово **Прямоугольник**, давайте **переопределим метод show_perimeter()** для **Cube**. По сути это действие и будет является с точки зрения ООП **полиморфизмом**. 

**Полиморфизм** — использование единственной сущности (метода, оператора или объекта) для представления различных типов в различных сценариях использования.

```
class Cube(Rectangle):

    def __init__(self, size: int) -> None:
        super().__init__(size, size)
        self.size = size

    #def __str__(self):
    #    return "jjjj" 

    # перегрузим родительский метод
    def show_perimeter(self) -> None:
        print(f"Периметр одной стороны куба: {self.perimeter()}")
```

# Добавление документации docstring

Документацию необходимо добавлять не только для описания классов, его атрибутов, но и для документирования ваших функций, которые не описаны в каком либо классе!

Какие есть типы docstring:

- одностроковые
- многостроковые

Если хотим посмотреть на документацию созданной функции в классе, то можем использовать метод _ _ doc _ _:


# Рекурсия

**Рекурсивная функция** — это та функция, которая вызывает сама себя. Данные функции используются для решения задач, которые могут быть разбиты на более мелкие подзадачи того же типа.  

Чтобы понять детальнее, для чего нужна рекурсия и как она применяется рассмотрим классический пример вычисления факториала.
Вспомним немного уроки математики из школы. Факториал – это результат умножения всех натуральных чисел меньше и включая заданное число.  
  

Перед тем, как начинать проектировать задачи при помощи python, попробуем разобрать ее руками и понять, где здесь рекурсия.
  
Более общая формула:
n! = n*(n-1)!

```
def factorial(data: int) -> Union[int, None]:
    if data > 0:
        if data == 1:
            return 1
        else:
            return data * factorial(data - 1)
            # 4 * factorial(4 - 1)
            #     3 * factorial(3 - 1)
            #         2 * factorial(2 - 1) = 2
            #     3 * 2 = 6
            # 4 * 6 = 24
    else:
        print('Введите положительное число')
  

print(factorial(4))
```

В данном примере мы учли базовый случай, где проверяем data==1, если бы мы не написали его, то код будет выполняться бесконечно, пока не закончится память, после чего случится аварийное завершение работы.

Бывают и более сложные варианты рекурсий (взаимная рекурсия), когда одна функция вызывает другую, которая затем вызывает первую, которая вызывает вторую и так далее. Количество функций здесь неограниченно.


# Сложность алгоритма

**Время** — основной параметр, характеризующий быстродействие алгоритма (вычислительная сложность).

Для упорядочения важны в терминах мощности входного множества (длины массива):

- Худшее
- Среднее
- Лучшее 

Пусть на входе множество A, где n = |A| (равно длине множества). Кол-во проходов по множеству и будет описывать сложность, например:

- Мы прошли в цикле массив один раз O(n)
- Мы прошли в цикле массив два раза O(n^2)
- Пример бинарного поиска O(log n)
![[Pasted image 20241021140347.png]]

  
  

https://proglib.io/p/slozhnost-algoritmov-i-operaciy-na-primere-python-2020-11-03
https://tproger.ru/articles/computational-complexity-explained/
https://www.youtube.com/watch?v=Fu4BzQNN0Qs  

**Память** — ряд алгоритмов требует выделения дополнительной памяти под временное хранение данных. Как правило, эти алгоритмы требуют O(log n) памяти.  Алгоритмы сортировки, не потребляющие дополнительной памяти, относят к сортировкам на месте.

## Константное время O(1)

```
values = [1, 2, 3]
  
# Пример 1 c O(1)
value = 15  

# Пример 2
def const(val: list):
    # O(1)
    return len(val)
```

## Линейная сложность O(N)

```
# Пример 1 c O(N) = O(3)

values = [1, 2, 4]  

# Пример 2 c O(N) = O(10)
sum_val = 0
for i in range(10):
    sum_val+=i
```

## Логарифмическое время O(logN)

```
# когда нам не нужно просматривать все элементы
# Binary Search
# ищем элемент в отсортированном массиве
# путем деления списка пополам
# переходим либо к левой, либо к правой половине списка
# и сравниваем элементы
  

# Квазилинейное

# O(N*logN) - Быстрая сортировка
# values.sort()
```

## Квадратичная сложность O(N^2)

```
# Пример c O(N^2)
sum_val = 0
values = [1, 2, 4]  

for i in range(len(values)):
    for j in range(len(values)):
        sum_val += i
```

## Сложность O(N1*N2)

```
# Пример c O(N1*N2)

sum_val = 0
values = [1, 2, 4]
values_2 = [1, 2, 4, 5]  

for i in range(len(values)):
    for j in range(len(values_2)):
        sum_val += i+j
```

## Отбрасывание константы / менее значимых элементов

```
# Пример c отбрасыванием константы

sum_val = 0
values = [1, 2, 4]  

# O(N)
for i in range(len(values)):
    sum_val += i  

# O(N)
for i in range(len(values)):
    sum_val += i

# O(N + N) = O(2N) = O(N)
```

```
# N1 = 5, N2 = 10

lst1 = [1, 2, 2, 3, 6]
lst2 = [1, 3, 3, 7, 11, 12, 12, 13, 14, 15]
# {1, 3}  

def similar(list_1: list, list_2: list) -> set:
    # O(1)
    sim = []
    # O(N1)
    for i in list_1:
        # O(N2)
        for j in list_2:
            # O(1) в худшем случае никогда не выполняется
            if i == j:
                # O(1) в худшем случае никогда не выполняется
                sim.append(i)
    # O(N3)

    return set(sim)
```

[[Вторая ступень. Основы Python и SQL._Content]]