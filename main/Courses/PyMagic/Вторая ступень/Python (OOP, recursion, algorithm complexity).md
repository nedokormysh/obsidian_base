
# Классы и объекты

**Объектно-ориентированное программирование (ООП)** — методология программирования, основанная на представлении программы в виде совокупности объектов, каждый из которых является экземпляром определённого класса, а классы образуют иерархию наследования.
Python соответствует принципам объектно-ориентированного программирования. В python всё является объектами - и строки, и списки, и словари, и всё остальное.
Но возможности ООП в python этим не ограничены. Программист может написать свой тип данных (класс), определить в нём свои методы.
Это не является обязательным - мы можем пользоваться только встроенными объектами. Однако ООП полезно при долгосрочной разработке программы несколькими людьми, так как упрощает понимание кода.  

**Какие есть преимущества ООП?**  

- Программа разбивается на объекты. Каждый объект отвечает за собственные данные и их обработку. В результате код становится читабельней и проще
- Ускоряется процесс написания программы, так как сначала создаете высокоуровневую структуру классов и базовый функционал, а далее переходите к их подробной реализации
- Не нужно дублицировать код. Есть возможность унаследовать дочернему классу функционал от родительского класса  

**Основные определения:**  

> **Класс** - это некий шаблон для создания объектов, описывает свойства и поведение, которыми могут обладать объекты  

> **Свойства класса (поля)** - это характеристики объекта класса (например: цвет, длина)  

> **Методы класса** - это функции, с помощью которых можно оперировать данными класса (например: посчитать производную)  

> **Объект (экземпляр класса)** — некоторая сущность, реализация какого-то класса, обладающая уже определённым состоянием и поведением  

> **Конструктор** - Создает экземпляр(объект) класса. Вызывается первым  

> **Деструктор** - Вызывается при удалении объекта сборщиком мусора  

> **ВАЖНО!** Название классов начинаются с заглавной буквы. Например: MyClass, CatDog

```
# Также доступны встроенные (служебные) атрибуты

# Документация класса

print(r.__doc__)
  

# Словарь, в котором хранится пространство имен класса

print(r.__dict__) 

# Список атрибутов класса
print(r.__dir__())

-----------
None {'x': 1} ['x', '__module__', '__dict__', '__weakref__', '__doc__', '__repr__', '__hash__', '__str__', '__getattribute__', '__setattr__', '__delattr__', '__lt__', '__le__', '__eq__', '__ne__', '__gt__', '__ge__', '__init__', '__new__', '__reduce_ex__', '__reduce__', '__subclasshook__', '__init_subclass__', '__format__', '__sizeof__', '__dir__', '__class__']
```

## Инициализация

В классе мы можем инициализировать объекты, а при помощи методов, производить над этими объектами действия.  

> **self** - это ссылка на конкретный экземпляр класса. При этом, self не зарезервировано как имя в python,  является лишь договоренностью  

> **cls** - это ссылка на класс, для которого запрошено конструирование объекта  

> **self** – сcылка на текущий экземпляр класса, он необходим для получения доступов к различным методам и переменным объявленным  в классе.  

> **метод _ _new_ _()** - конструктор, вызывается при создании класса.  

> **метод _ _init_ _()** - инициализатор, принимает созданный конструктором объект, позволяет инициализировать, то есть объявить ваши переменные, которые вы сможете потом повсеместно использовать в вашем классе.  

Каждый раз, когда создается новый объект Rectangle, метод _ _init_ _() устанавливает начальное состояние, присваивая свойствам значения (инициализирует каждый новый экземпляр класса)

  В _ _init_ _ также указан self, он необходим, чтобы вы закрепили в самом начале адресацию на ваши переменные.

**ВАЖНО:** self - это незарезервированное имя, просто как соглашение между программистами

> При вызове super()._ _ new _ _(cls) мы получаем доступ к методу object._ _ new _ _() родительского класса **object**, который является базовой реализацией метода .__new__() для всех классов Python

> На практике вы используете метод _ _ new _ _(), когда хотите настроить объект в момент времени создания экземпляра. 

> obejct - является базовым классом для всех классов Python по умолчанию

```
class Rectangle:

    # это атрибуты класса
    # статические поля (свойства или переменные класса)
    COLOR = 'green'

    # конструктор
    # *args, **kwargs - для гибкости метода
    def __new__(cls, *args, **kwargs):
        print(f'Design: {args} | {kwargs}')
        print(f'Creating a new {cls.__name__} object...')
        obj = super().__new__(cls)
        # это атрибуты экземпляра класса
        obj.new_attribute = 'добавлено'
        return obj

  

    # инициализатор
    def __init__(self, width: int, length: int) -> None:
        print(f'Initializing the Rectangle object...\n')
        # это атрибуты экземпляра класса
        # динамические поля (свойства или переменные экземпляра класса)
        self.width = width
        self.length = length

  
    # метод экземпляра класса (также атрибут)
    def perimeter(self) -> int:
        return (self.width + self.length) * 2
        
    # метод экземпляра класса (также атрибут)
    def show_perimeter(self) -> None:

        print(f"Периметр прямоугольника: {self.perimeter()}")

  


r = Rectangle(width=5, length=2)

print(f"Статическая переменная: {r.COLOR = }\n")

print(f"Динамическая переменная: {r.width = }\n")

r.show_perimeter()

print(r.new_attribute)
------------
Design: () | {'width': 5, 'length': 2}
Creating a new Rectangle object...
Initializing the Rectangle object...
Статическая переменная: r.COLOR = 'green'
Динамическая переменная: r.width = 5
Периметр прямоугольника: 14 добавлено
```

В конструкторе класса мы можем добавить какую-нибудь проверку при создании нового объекта класса. Например, проверку на неотрицательность передаваемых параметров.

Если вы хотите использовать какие-то конкретные значения при инициализации, то можно прописать переменную с ее значением в **init** с указанием self:

## Методы 

### Статичный метод

> **@staticmethod** — используется для создания метода, который ничего не знает о классе или экземпляре, через который он был вызван. Он просто получает переданные аргументы, без неявного первого аргумента, и его определение неизменяемо через наследование.

  Проще говоря, @staticmethod — это вроде обычной функции, определенной внутри класса, которая не имеет доступа к экземпляру, поэтому ее можно вызывать без создания экземпляра класса.
```
# для статического можно ничего не передавать

    # либо передавать параметры. НО НЕ ссылку self на объекты класса!!
    @staticmethod
    def perimeter(x: int, y: int) -> int:
        return (x + y) * 2

# статический метод я могу вызвать, не создавая экземпляр класса
Rectangle.perimeter(2, 4)
```

### Метод класса

> **@classmethod** — это декоторатор, определяет метод класса, который получает класс в качестве неявного первого аргумента, точно так же, как обычный метод экземпляра получает экземпляр. Это означает, что вы можете использовать класс и его свойства внутри этого метода, а не конкретного экземпляра.

> classmethod — это метод, который **привязан к классу, а не к экземпляру класса**

Проще говоря, **classmethod** — это обычный метод класса, имеющий доступ ко всем атрибутам класса, через который он был вызван.

```
class Rectangle:

    VOLUME = 24

    def __init__(self, width: int, length: int) -> None:

        self.width = width
        self.length = length
    # метод класса работает с атрибутами класса, но не c экзепляром
    # пусть нам хочется из объема параллелипипида,
    # его ширины и высоты -> получить ширину и длину

    @classmethod
    def change_params(cls, width, height):
        # вернет экземпляр класса, так как используем cls
        # cls - указывает не на объект, а на сам класс
        print(f"{cls.VOLUME = }")
        return cls(width, (cls.VOLUME / (width * height)))

  

    def perimeter(self) -> int:

        return (self.width + self.length) * 2

  

    def show_perimeter(self) -> None:

        print(f"Периметр прямоугольника: {self.perimeter()}")

  
  

r = Rectangle(1, 2)

r.show_perimeter()
------
Периметр прямоугольника: 6
```

```
rec_ex = Rectangle.change_params(width=3, height=4)

# тогда length = 2
# и по идее perimeter = (2 + 3)*2 = 10
rec_ex.show_perimeter()
------
cls.VOLUME = 24 Периметр прямоугольника: 10.0
```