## Синтаксис

Создание функций необходимо, чтобы упростить вашу программу, описать повторяющиеся элементы кода, которые вы сможете переиспользовать в других местах.

Если вы работаете над большим проектом, то важно придерживаться принципа Don’t Repeat Yourself (DRY, избегайте самоповторов). Как один из способов придерживаться данного принципа – использовать циклы и функции.

  Этот принцип неразрывно связан с функциональным программированием.

  В Python функция определяется с помощью ключевого слова def. После того, как вы назвали свою функцию и поставили круглые скобки, необходимо указать знак двоеточия. Следующие строки должны быть с отступом от строки с объявлением функции.

Между определением функии и вызовом ее ставим две пустые строки

  

**PEP8. Пустые строки:**

- Определения внешних классов и функций окружается двумя пустыми строками
- Определения методов внутри класса заключены в одну пустую строку.
- Дополнительные пустые строки могут использоваться для разделения групп связанных функций. Пустые строки могут быть пропущены между связкой связанных строк (например, набором фиктивных реализаций).
- Используйте пустые строки в функциях, чтобы указать логические разделы.

```
# При создании функции определяются ее параметры

def welcome(name: str) -> None:

    print(f"Hello {name}")

  
  

# При вызове функций, ей передаются аргументы

welcome(name="Nastya")
```
```
def welcome(name: str, year: int) -> None:

    print(f"Hello {name}, you was born in {year}")

  
  

# Если несколько аргументов без использования имен,

# то передаем согласно позиции имен (позиционные аргументы)

welcome("Nastya", 2001)
```

**ВАЖНО:** 

- При вызове функции ключевые аргументы должны следовать за позиционными аргументами
- Порядок ключевых аргументов не важен

## Аннотация типов

Чтобы понимать, какие вы данные подаете на вход и какие возвращаете, то после каждого параметра после двоеточия указываете его тип, так проще и легче ориентироваться будет другому человеку при работе над кодом и ревью. После круглых скобок через стрелочку вы указываете тип возвращаемого значения.
  

- Для случаев, когда необходимо допустить использование не любых типов, а только некоторых, можно использовать аннотацию **typing.Union** с указанием списка типов в квадратных скобках.
- Если вы пометите переменную типом int и захотите присвоить ей None, то для таких случаев предусмотрена в модуле typing аннотация **Optional** с указанием конкретного типа. Обратите внимание, тип опциональной переменной указывается в квадратных скобках
- Если вы не хотите ограничивать возможные типы переменной. Например, если это действительно не важно, или если вы планируете сделать обработку разных типов самостоятельно. В этом случае, можно использовать аннотацию **Any**.

```
def my_function(parameters: Optional[int] = None) -> None:

    print("Hello from a function " + str(parameters))
  

my_function(123)
```
```
def my_function(parameters: Union[int, float, str]) -> None:

    print("Hello from a function " + str(parameters))
  
  my_function('stroka')
```

## Передача параметров функции

Существует несколько способов передачи функции различного количества аргументов. Первый способ часто является наиболее интуитивно понятным: вы просто передаете список или набор всех аргументов своей функции. Таким образом, для my_sum() вы можете передать список всех целых чисел, которые вам нужно добавить:
```
def summation(x: Union[int, float], y: [int, float]) -> Union[int, float]:

    return x + y

  
  

print(summation(x=10, y=11))
```

Эта реализация работает, но всякий раз, когда вы вызываете эту функцию, вам также потребуется создать список аргументов для передачи ей. Это может быть неудобно, особенно если вы заранее не знаете всех значений, которые должны быть включены в список.

Для этого используется **args**, он может быть полезен, потому что позволяет передавать различное количество аргументов.

args нужен, когда мы хотим передать **неизвестное количество неименованных аргументов**. Если поставить * перед именем, это имя будет принимать не один аргумент, а несколько. Аргументы могут передаются как кортеж и доступны внутри функции под тем же именем, что и имя параметра, только без *.

```
def summation(*args: Union[int, float]) -> Union[int, float]:

    print(f"{type(args) = }")

    return sum(args)

  
  

summation(1, 2, 3.6, 7, 7, 1, 999)
```

Обратите внимание, что **args** - это просто имя. Вы не обязаны использовать имя args. Вы можете выбрать любое имя, которое вам больше нравится.

При помощи **kwargs** мы можем передавать в функцию словари, но если используем *args, то можем передать только кортежи. Возьмем следующий пример:

```
def concatenate(**kwargs: str) -> str:

    print(f"{type(kwargs) = }")

  

    result = ""

    for arg in kwargs.values():

        result += arg

    return result

  
  

concatenate(a="Real", b="Python", c="Is", d="Great", e="!")
```

- *args позволяет передавать произвольное число неименованных аргументов

- **kwargs произвольное число именованных аргументов.

## Итераторы

**Итератор** — это интерфейс, предоставляющий доступ к элементам коллекции (массива или контейнера). Итератор только предоставляет доступ, но не выполняет итерацию по ним.

  
Также есть такие понятия как:
  
- Итерируемый объект - любой объект, имеющий методы __iter__ или __getitem__, которые возвращают итераторы или могут принимать индексы. Итерируемый объект – это объект, который может предоставить нам итератор
- Итератор - объект, который имеет метод next (Python 2) или __next__
- Итерация - это процесс получения элементов из какого-нибудь источника, например списка, если проще то – это процесс перебора элементов объекта в цикле. Если элементов в списке не осталось, то возвращает исключение StopIteration.

```
value = iter([1, 5, 3, 6])

  

print(type(value))
#<class 'list_iterator'>
```

А теперь, попробуем получить элементы при помощи встроенного метода next() (можно также использовать **next**()
```
print(next(value))
# 1
```
Обратите внимание, как итератор сохраняет свое внутреннее состояние. Он знает, какие значения уже были получены, поэтому, когда вы вызываете next(), он знает, какое значение возвращать следующим.

Что происходит, когда в итераторе заканчиваются значения? Давайте сделаем еще несколько вызовов next() для итератор
```
---------------------------------------------------------------------------

StopIteration                             Traceback (most recent call last)

<ipython-input-37-b3bc804c51e6> in <module>
      5 print(next(value))
      6 print(next(value))
----> 7 print(next(value))

StopIteration
```

Если все значения из итератора уже возвращены, последующий вызов next() вызывает исключение StopIteration. Любые дальнейшие попытки получить значения из итератора завершатся неудачей.

В Python у каждого итератора присутствует метод **iter** - то есть, любой итератор является итерируемым объектом. Этот метод просто возвращает сам итератор.

**Какие типы данных можно итерировать:**

- Строки
- Списки
- Кортежи
- Словари
- Множества (set и frozenset)
Нельзя:

- Числовые значения