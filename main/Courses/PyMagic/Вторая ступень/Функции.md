## Синтаксис

Создание функций необходимо, чтобы упростить вашу программу, описать повторяющиеся элементы кода, которые вы сможете переиспользовать в других местах.

Если вы работаете над большим проектом, то важно придерживаться принципа Don’t Repeat Yourself (DRY, избегайте самоповторов). Как один из способов придерживаться данного принципа – использовать циклы и функции.

  Этот принцип неразрывно связан с функциональным программированием.

  В Python функция определяется с помощью ключевого слова def. После того, как вы назвали свою функцию и поставили круглые скобки, необходимо указать знак двоеточия. Следующие строки должны быть с отступом от строки с объявлением функции.

Между определением функии и вызовом ее ставим две пустые строки

  

**PEP8. Пустые строки:**

- Определения внешних классов и функций окружается двумя пустыми строками
- Определения методов внутри класса заключены в одну пустую строку.
- Дополнительные пустые строки могут использоваться для разделения групп связанных функций. Пустые строки могут быть пропущены между связкой связанных строк (например, набором фиктивных реализаций).
- Используйте пустые строки в функциях, чтобы указать логические разделы.

```
# При создании функции определяются ее параметры

def welcome(name: str) -> None:

    print(f"Hello {name}")

  
  

# При вызове функций, ей передаются аргументы

welcome(name="Nastya")
```
```
def welcome(name: str, year: int) -> None:

    print(f"Hello {name}, you was born in {year}")

  
  

# Если несколько аргументов без использования имен,

# то передаем согласно позиции имен (позиционные аргументы)

welcome("Nastya", 2001)
```

**ВАЖНО:** 

- При вызове функции ключевые аргументы должны следовать за позиционными аргументами
- Порядок ключевых аргументов не важен

## Аннотация типов

Чтобы понимать, какие вы данные подаете на вход и какие возвращаете, то после каждого параметра после двоеточия указываете его тип, так проще и легче ориентироваться будет другому человеку при работе над кодом и ревью. После круглых скобок через стрелочку вы указываете тип возвращаемого значения.
  

- Для случаев, когда необходимо допустить использование не любых типов, а только некоторых, можно использовать аннотацию **typing.Union** с указанием списка типов в квадратных скобках.
- Если вы пометите переменную типом int и захотите присвоить ей None, то для таких случаев предусмотрена в модуле typing аннотация **Optional** с указанием конкретного типа. Обратите внимание, тип опциональной переменной указывается в квадратных скобках
- Если вы не хотите ограничивать возможные типы переменной. Например, если это действительно не важно, или если вы планируете сделать обработку разных типов самостоятельно. В этом случае, можно использовать аннотацию **Any**.

```
def my_function(parameters: Optional[int] = None) -> None:

    print("Hello from a function " + str(parameters))
  

my_function(123)
```
```
def my_function(parameters: Union[int, float, str]) -> None:

    print("Hello from a function " + str(parameters))
  
  my_function('stroka')
```

## Передача параметров функции

Существует несколько способов передачи функции различного количества аргументов. Первый способ часто является наиболее интуитивно понятным: вы просто передаете список или набор всех аргументов своей функции. Таким образом, для my_sum() вы можете передать список всех целых чисел, которые вам нужно добавить:
```
def summation(x: Union[int, float], y: [int, float]) -> Union[int, float]:
    return x + y
  
print(summation(x=10, y=11))
```

Эта реализация работает, но всякий раз, когда вы вызываете эту функцию, вам также потребуется создать список аргументов для передачи ей. Это может быть неудобно, особенно если вы заранее не знаете всех значений, которые должны быть включены в список.

Для этого используется **args**, он может быть полезен, потому что позволяет передавать различное количество аргументов.

args нужен, когда мы хотим передать **неизвестное количество неименованных аргументов**. Если поставить * перед именем, это имя будет принимать не один аргумент, а несколько. Аргументы могут передаются как кортеж и доступны внутри функции под тем же именем, что и имя параметра, только без *.

```
def summation(*args: Union[int, float]) -> Union[int, float]:

    print(f"{type(args) = }")

    return sum(args)

  
  

summation(1, 2, 3.6, 7, 7, 1, 999)
```

Обратите внимание, что **args** - это просто имя. Вы не обязаны использовать имя args. Вы можете выбрать любое имя, которое вам больше нравится.

При помощи **kwargs** мы можем передавать в функцию словари, но если используем *args, то можем передать только кортежи. Возьмем следующий пример:

```
def concatenate(**kwargs: str) -> str:

    print(f"{type(kwargs) = }")

  

    result = ""

    for arg in kwargs.values():

        result += arg

    return result

  
  

concatenate(a="Real", b="Python", c="Is", d="Great", e="!")
```

- *args позволяет передавать произвольное число неименованных аргументов

- **kwargs произвольное число именованных аргументов.

## Итераторы

**Итератор** — это интерфейс, предоставляющий доступ к элементам коллекции (массива или контейнера). Итератор только предоставляет доступ, но не выполняет итерацию по ним.

  
Также есть такие понятия как:
  
- Итерируемый объект - любой объект, имеющий методы __iter__ или __getitem__, которые возвращают итераторы или могут принимать индексы. Итерируемый объект – это объект, который может предоставить нам итератор
- Итератор - объект, который имеет метод next (Python 2) или __next__
- Итерация - это процесс получения элементов из какого-нибудь источника, например списка, если проще то – это процесс перебора элементов объекта в цикле. Если элементов в списке не осталось, то возвращает исключение StopIteration.

```
value = iter([1, 5, 3, 6])

  

print(type(value))
#<class 'list_iterator'>
```

А теперь, попробуем получить элементы при помощи встроенного метода next() (можно также использовать **next**()
```
print(next(value))
# 1
```
Обратите внимание, как итератор сохраняет свое внутреннее состояние. Он знает, какие значения уже были получены, поэтому, когда вы вызываете next(), он знает, какое значение возвращать следующим.

Что происходит, когда в итераторе заканчиваются значения? Давайте сделаем еще несколько вызовов next() для итератор
```
---------------------------------------------------------------------------

StopIteration                             Traceback (most recent call last)

<ipython-input-37-b3bc804c51e6> in <module>
      5 print(next(value))
      6 print(next(value))
----> 7 print(next(value))

StopIteration
```

Если все значения из итератора уже возвращены, последующий вызов next() вызывает исключение StopIteration. Любые дальнейшие попытки получить значения из итератора завершатся неудачей.

В Python у каждого итератора присутствует метод **iter** - то есть, любой итератор является итерируемым объектом. Этот метод просто возвращает сам итератор.

**Какие типы данных можно итерировать:**

- Строки
- Списки
- Кортежи
- Словари
- Множества (set и frozenset)
Нельзя:

- Числовые значения

Но это ни в коем случае не единственные типы, которые вы можете перебирать. Многие объекты, встроенные в Python или в определенные в модули, предназначены для итераций. Например, файлы, их в Python можно итерировать. Фактически, почти любой объект в Python можно сделать итеративным. Даже пользовательские объекты могут быть спроектированы таким образом, чтобы их можно было повторять.

Если итератор value1 уже находится в конце списка, value2 все еще находится в начале. Каждый итератор поддерживает свое собственное внутреннее состояние, независимое от другого.

## Генераторы

**Генераторы** – это итераторы (но не наоборот), по которым можно итерировать только один раз. Так происходит поскольку они не хранят все свои значения в памяти, а генерируют элементы как бы "на ходу".

В отличие от списков, они ленивы и поэтому работают с текущим элемент только по запросу. Таким образом, они намного эффективнее используют память при работе с большими наборами данных.  

**Зачем нужны генераторы?**
Это средство отложенных вычислений. Значения вычисляются только тогда, когда они действительно необходимы. Это намного удобнее, если мы, например, будем за раз вычислять огромный список и еще держать его в памяти.  

**Генератор можно реализовать двумя способами:**

- функция с ключевым словом yield
- генераторное выражение.  

В результате вызова функции или вычисления выражения, получаем объект-генератор типа types.GeneratorType.

```
genexpr = (x**2 for x in range(10000))
 

print(genexpr)

# <generator object <genexpr> at .....>

  

print(next(genexpr))

# Вывод: 0
print(next(genexpr))
# Вывод: 1
print(next(genexpr))
# Вывод: 4

-----
<generator object <genexpr> at 0x7fdf20b09a50>
0
1
4
```

```
example = [6, 2, 4, 7]

  

# создает объект-генератор, который генерирует кортежи,

# состоящие из двух элементов – индекса элемента и самого элемента

example_en = enumerate(example)

example_en
```
```
next(example_en)
----
(0, 6)
```
```
example = [100, 110, 40, 75]

lst_str = ['client1', 'client2', 'client3', 'client4']

  

# zip - поэлементно группирует в кортежи

z = zip(example, lst_str)
```

### yield

Ключевое слово **yield**, в отличие от оператора return, используется для **превращения обычной функции Python в генератор**. Оно используется в качестве альтернативы одновременному возвращению целого списка.

yield используют не потому, что это определено синтаксисом Python, ведь всё, что можно реализовать с его помощью, можно реализовать и с помощью обычного return. Программисты предпочитают применять генераторы в тех случаях, когда нет необходимости сохранять всю последовательность и промежуточные значения в памяти.

Создадим функцию, которая на вход будет принимать список значений и возвращать список, где к каждому из значению добавляется 1:
Теперь вместо return напишем yield, запишем его под цикл и посмотрим на тип данных, а также значения
```
# Generator[yield_type, send_type, return_type]
# Либо Iterator[Union[int, float]]
# https://docs.python.org/3/library/typing.html#typing.Generator

  

def my_function(counts: List[int]) -> Generator[list, None, None]:
    arr = []
    for count in counts:
        arr.append(count+1)
        yield arr  

res = my_function([10, 11, 12])
print(type(res))

print(res)
----------
<class 'generator'>
<generator object my_function at 0x7fdf380cb2e0>
```
```
next(res)
------
[11]
```
```
next(res)
--------
[11, 12]
```

```
def infinite_stream(start: int) -> Generator[float, None, None]:

    while True:

        yield start

        start += 2.4

  
  

res = infinite_stream(1)
```
В первый запуск вашей функции, она будет исполняться от начала до того момента, когда она наткнётся на yield — тогда она вернёт первое значение из цикла. На каждый следующий вызов будет происходить ещё одна итерация написанного вами цикла, возвращаться будет следующее значение — и так пока значения не кончатся.

## lambda

**Лябмда-выражения** — это особый синтаксис в Python, необходимый для создания анонимных функций. Лямбда-выражения в Python позволяют функции быть созданной и переданной (зачастую другой функции) в одной строчке кода.

Давайте рассмотрим пример для большей наглядности, есть какая-то функция, которая вызывает саму себя, она принимает только один аргумент:
```
lambda x: x
```
сначала идет название самого выражения – лямбда, для обозначения такой функции, далее аргумент, который подаем на вход функции и через двоеточие само выражение, значение которого нужно вернуть, но обязательно, используя ранее объявленный аргумент или аргументы после лямбда.
```
lambda x: x + 1
```

Если мы хотим подать значение на вход лямбда функции, то необходимо все выражение поместить в скобки и рядом также в скобках указать значение
```
(lambda x: x + 1)(3)
```

```
(lambda x, y, z: x + y + z)(3, 9, 1)
```
## map()

Функция map первым аргументом ожидает объект функции и любое количество объектов для перебора, таких как dict или list. Он выполняет function_object – функцию для каждого элемента в последовательности и возвращает список элементов, измененных объектом функции.
```
def multiply(x: int) -> int:

    return x * 2

  
  

val = map(multiply, (1, 2, 3, 4))

print(val)

  

for x in val:

    print(x)
----
<map object at 0x7ec865fba050>
2
4
6
8
```

```
list(map(multiply, [1, 2, 3, 4]))
------
[2,4,6,8]
```

```
lst = [1, 2, 3, 4]

val = map(lambda x: x * 2, lst)
-----
2
4
6
8
<map object at 0x7fdf20b10640>
[1, 2, 3, 4]
```

## filter()

Функция filter ожидает два аргумента, function_object – функцию и iterable. function_object должна возвращать логическое значение. function_object вызывается для каждого элемента итерации, и фильтр возвращает только те элементы, для которых function_object возвращает true.

```
a = [1, 2, 3, 4, 5, 6]

val = filter(lambda x: x % 2 == 0, a)

  

for x in val:

    print(x)
----
2
4
6
```

Так как мы получаем итерируемый объект, что при filter и map, то и получать доступ к нему можем соответствующим образом.

```
lst = [1, 2, 3, 4, 5, 6]

val = filter(lambda x: x > 4, lst)
----
next(val)
5
```

# Исключения

**Исключения (exceptions)** - ещё один тип данных в python. Исключения необходимы для того, чтобы сообщать программисту об ошибках.

Деление на ноль

Разберём это сообщение подробнее:

- Интерпретатор нам сообщает о том, что он поймал исключение и напечатал информацию (Traceback (most recent call last)).
- Далее имя файла (File ""). Имя пустое, потому что мы находимся в интерактивном режиме, строка в файле (line 1);
- Выражение, в котором произошла ошибка (100 / 0).
- Название исключения (ZeroDivisionError) и краткое описание исключения (division by zero).

Наиболее частые исключения:

- ImportError – импортирование не удалось
- IndexError – индекс не входит в диапазон элементов списка
- NameError – попытка использовать несуществующую переменную
- SyntaxError – ошибка разбора кода
- TypeError – в функционал передано значение несовместимого кода
- ValueError – в функцию передано значение совместимого типа, но с некорректным значением
В Python есть целая иерархия исключений
 

https://tatyderb.gitbooks.io/python-express-course/content/chapter_exception/3_tree.html

```
# Для обработки исключений используют конструкцию try-except

  

try:
	print('work')
    num = 100 / 0
    print('work_2')
except ZeroDivisionError:
    num = 0
 

print(num)
-------
work 
0
```

Также except может содержать несколько исключений
```
try:
	num = 100
    print(num + 'hello')
    print(num / 2)
except ZeroDivisionError:
    print('Divided by zero')
except (ValueError, TypeError):
    print('Error occurred')
 ---
Error occured
```

КАК ЖЕЛАТЕЛЬНО
```
try:
    num = 'Hello'
    print(num / 0)
except Exception as ex:
    # print('Error')
    print(f'An error occurred. message {ex}')
```

И ИДЕАЛЬНО

```
try:
    num = 'Hello'
    print(num / 0)
except TypeError as ex:
    print(f'An error occurred. message {ex}')
```
Если мы хотим выводить на экран сообщение об ошибке, то напишем через алиас сокращенное название и подадим в print

Аналогично можем поступить с общим исключением Exception

```
try:
    num = 100
    print(num / 0)
except Exception as ex:
    print(f'message: {ex}')
```

Если вам необходимо, чтобы вне зависимости от того, возникли ошибки в коде или нет, некоторый фрагмент кода выполнялся, то используйте конструкцию **finally**

Она располагается в нижней части конструкции try/except. finally выполняется всегда после блока try, и, если возможно, после блока except.

```
try:
    print('first')
    print(100 / 0)
    print('second')
except ZeroDivisionError as ex:
    print(f"message: {ex}")
finally:
    print('Hello world!')
--------
first
message: division by zero
Hello world!
```
Если какая-либо конструкция не смогла перехватиться, то finally будет выполняться.
Чтобы использовать исключения в самой функции, необходимо подставить данный каркас в функцию

**raise** - принудительный вызов ошибки

```
def my_function(value: int) -> None:
    try:
        if value % 2 != 0:
            raise ValueError('Используйте четное значение')
        return 100 / value

    # указываем соответсвующее исключение!!!

    except (ZeroDivisionError, TypeError) as ex:
        print(f'message: {ex}')
        raise


# Вызов функции

my_function(value=0)

------
message: division by zero

---------------------------------------------------------------------------

ZeroDivisionError                         Traceback (most recent call last)

<ipython-input-104-6a05ce6e002f> in <module>
     11      12 # Вызов функции
---> 13 my_function(value=0)

<ipython-input-104-6a05ce6e002f> in my_function(value)
      3         if value % 2 != 0:
      4             raise ValueError('Используйте четное значение')
----> 5         return 100 / value
      6     # указываем соответсвующее исключение!!!
      7     except (ZeroDivisionError, TypeError) as ex:

ZeroDivisionError: division by zero

```

[[Вторая ступень. Основы Python и SQL._Content]]