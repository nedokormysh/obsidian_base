
что если в результат группировки и агрегации мы хотим включить не все группы, а только те, для которых выполняется некоторое условие? Например, только те размеры заказов, количество которых выше или ниже определённого значения? Или только те возрастные группы, количество пользователей в которых превышает заданный порог?

Судя по всему, для этого нам необходимо каким-то образом наложить фильтрацию уже поверх группировки. Но, как мы выяснили, оператор `WHERE` использовать после `GROUP BY` нельзя. Что же тогда делать?

Специально для таких случаев существует оператор `HAVING`, который тоже выполняет функцию фильтрации, но работает поверх уже сгруппированных данных.

В этом и заключается ключевое отличие операторов `WHERE` и `HAVING`: первый фильтрует записи в таблице перед группировкой и агрегацией, а второй — после. Кстати, это простой, но довольно популярный вопрос на собеседовании по SQL.

Ещё одна важная особенность работы оператора `HAVING`: в этом блоке нельзя указывать алиасы полей с результатом агрегации из блока `SELECT`. Дело в том, что в соответствии с порядком выполнения запроса оператор `SELECT` выполняется после оператора `HAVING`. Поэтому агрегацию необходимо также указывать и в `HAVING`.

SELECT column_1, SUM(column_2) AS new_column
FROM table
GROUP BY column_1
HAVING SUM(column_2) = 100

Кроме того, в `HAVING` не обязательно указывать ту же агрегацию, что и в блоке `SELECT`, равно как и в `SELECT` не обязательно указывать агрегацию из `HAVING`:

SELECT column_1, SUM(column_2) AS new_column
FROM table
GROUP BY column_1
HAVING AVG(column_3) < 50

Иными словами, в `HAVING` фильтрация может производиться по результату одной агрегации, а в результирующую таблицу при этом включаться совсем другая агрегация (в том числе по другой колонке).

Впрочем, в `SELECT` можно вообще ничего не указывать кроме колонки, по которой производится группировка:

SELECT column_1
FROM table
GROUP BY column_1
HAVING SUM(column_2) = 100 AND AVG(column_3) < 50 

Здесь важно понять, что группировка, агрегация и фильтрация групп со всеми расчётами происходят всегда до выполнения инструкций в блоке `SELECT`, где вы просто определяете, что попадёт в результирующую таблицу.

Таким образом, мы снова можем дополнить список ключевых слов в запросе:

1. `SELECT`
2. `FROM`
3. `WHERE`
4. `GROUP BY`
5. **`HAVING`**
6. `ORDER BY`
7. `LIMIT`

Порядок их выполнения в запросе следующий:

1. Сначала выполняется оператор `FROM` — происходит выбор нужной таблицы.
2. Далее `WHERE` — отфильтровываются строки, соответствующие условию.
3. Потом `GROUP BY` — строки объединяются в группы и производится агрегация.
4. Затем `HAVING` — отфильтровываются группы, соответствующие условию.
5. После этого `SELECT` — отбираются указанные столбцы.
6. Потом `ORDER BY` — производится сортировка результирующей таблицы.
7. И в самом конце `LIMIT` — ограничивается количество выводимых записей.

Давайте дополним наш предыдущий запрос оператором `HAVING` и заодно немного поменяем условие в `WHERE`: проведём расчёты только для заказов, сделанных по будням.

Для получения наименования дня недели из колонки с датой или отметкой времени можно использовать, например, функцию `DATE_PART` с параметром 'isodow' либо функцию `TO_CHAR` с параметром 'Dy':

SELECT TO_CHAR(TIMESTAMP '2022-08-29', 'Dy')

Результат:
Mon

## **Задание:**

Посчитайте количество товаров в каждом заказе, примените к этим значениям группировку и рассчитайте количество заказов в каждой группе. Учитывайте только заказы, оформленные по будням. В результат включите только те размеры заказов, общее число которых превышает 2000. Для расчётов используйте данные из таблицы `orders`.

Выведите две колонки: размер заказа и число заказов такого размера. Колонки назовите соответственно `order_size` и `orders_count`.

Результат отсортируйте по возрастанию размера заказа.

Поля в результирующей таблице: `order_size`, `orders_count`


SELECT array_length(product_ids, 1) as order_size,
       count(order_id) as orders_count
FROM   orders
WHERE  to_char(creation_time, 'Dy') not in ('Sat', 'Sun')
GROUP BY order_size having count(order_id) > 2000
ORDER BY order_size


[[Группировка_данных_content]]