Расчётные колонки можно использовать не только для того, чтобы группировать по ним данные. Их можно также использовать в качестве полей, по которым производится агрегация внутри групп.

Иными словами, агрегацию не обязательно проводить по уже имеющимся колонкам — колонки можно «создавать» в рамках того же запроса, в котором происходит группировка:

SELECT column_1, MIN(DATE_TRUNC('month', column_2)) AS min_month
FROM table
GROUP BY column_1

SELECT column_1, DATE_TRUNC('month', MIN(column_2)) AS min_month
FROM table
GROUP BY column_1

Получается, что и к результату агрегирующей функции можно сразу же применять другие функции.

При этом в примерах выше не имеет значения, в каком порядке проводить вычисления: мы можем сначала округлить даты, а затем найти среди них минимальную, или же сначала найти минимальную дату и затем округлить её.

Но нужно быть внимательными: часто результат зависит от того, в каком порядке применяются обычные и агрегирующие функции. Например, следующие два запроса дадут разный результат:

SELECT column_1, MIN(DATE_PART('month', column_2)) AS min_month
FROM table
GROUP BY column_1


SELECT column_1, DATE_PART('month', MIN(column_2)) AS min_month
FROM table
GROUP BY column_1

В первом запросе из каждой даты в колонке column_2 мы сначала выделяем все порядковые номера месяцев, а затем в каждой группе находим среди них минимальный. В то же время во втором запросе сначала определяется минимальная дата в каждой группе, а потом вычисляется порядковый номер месяца в этой дате.

Разумеется, результат может отличаться, поскольку в данных могут быть даты за разные годы — в самом раннем году могут не оказаться даты с некоторыми месяцами, тогда как в более поздних годах даты с этими месяцами будут. Из-за этого и возможна ситуация, когда запросы будут давать разный результат.

Давайте рассмотрим подобные случаи на практике.

---

## **Задание:**

По данным в таблице `users` посчитайте максимальный порядковый номер месяца среди всех порядковых номеров месяцев рождения пользователей сервиса. С помощью группировки проведите расчёты отдельно в двух группах — для пользователей мужского и женского пола.

Новую колонку с максимальным порядковым номером месяца рождения в группах назовите `max_month`. Преобразуйте значения в новой колонке в формат `INTEGER`, чтобы порядковый номер был выражен целым числом.

Результат отсортируйте по колонке с полом пользователей.

Поля в результирующей таблице: `sex`, `max_month`

SELECT sex,
       max(date_part('month', birth_date))::integer as max_month
FROM   users
GROUP BY sex
ORDER BY sex

## **Задание:**

По данным в таблице `users` посчитайте порядковый номер месяца рождения самого молодого пользователя сервиса. С помощью группировки проведите расчёты отдельно в двух группах — для пользователей мужского и женского пола.

Новую колонку c порядковым номером месяца рождения самого молодого пользователя в группах назовите `max_month`. Преобразуйте значения в новой колонке в формат `INTEGER`, чтобы порядковый номер был выражен целым числом.

Результат отсортируйте по колонке с полом пользователей.

Поля в результирующей таблице: `sex`, `max_month`

---

**Пояснение:**

Для получения порядкового номера месяца из даты пригодится функция `DATE_PART`.

SELECT sex,
       date_part('month', max(birth_date))::integer as max_month
FROM   users
GROUP BY sex
ORDER BY sex

## Теперь ещё немного усложним запрос.

Давайте посчитаем максимальный возраст клиентов нашего сервиса — с помощью группировки сделаем это отдельно для пользователей мужского и женского пола. При этом выведем не возраст в днях, а только число полных лет.

---

## **Задание:**

Посчитайте максимальный возраст пользователей мужского и женского пола в таблице `users`. Возраст измерьте числом полных лет.

Новую колонку с возрастом назовите `max_age`. Преобразуйте значения в новой колонке в формат `INTEGER`, чтобы возраст был выражен целым числом.

Результат отсортируйте по новой колонке по возрастанию возраста.

Поля в результирующей таблице: `sex`, `max_age`

---

**Пояснение:**

Для вычисления количества полных лет используйте функцию `AGE`.

В качестве даты, относительно которой считать возраст пользователей, используйте свою текущую дату.

Чтобы извлечь число полных лет из возраста, можно использовать функцию `DATE_PART` с аргументом 'year'.



Время не стоит на месте, поэтому верный ответ может отличаться от примера в ожидаемом результате. Используйте его как ориентир формата ответа.

SELECT sex,
       date_part('year', max(age(birth_date)))::integer as max_age
FROM   users
GROUP BY sex
ORDER BY max_age

## сколько клиентов определённого возраста пользуются нашим сервисом

## **Задание:**

Разбейте пользователей из таблицы `users` на группы по возрасту (возраст по-прежнему измеряем числом полных лет) и посчитайте количество пользователей каждого возраста.

Колонку с возрастом назовите `age`, а колонку с числом пользователей — `users_count`. Преобразуйте значения в колонке с возрастом в формат `INTEGER`, чтобы возраст был выражен целым числом.

Результат отсортируйте по колонке с возрастом по возрастанию.

Поля в результирующей таблице: `age`, `users_count`

---

**Пояснение:**

Число полных лет из возраста рассчитывайте тем же способом, что и в предыдущем задании.

Обратите внимание, что у части пользователей вместо возраста будет пропуск. Эту группу также включите в результат и посчитайте число пользователей в ней.

В данной задаче вам необходимо провести группировку по новому расчётному полю. Помните, что повторно производить вычисления в `GROUP BY` не обязательно, достаточно взять алиас колонки из `SELECT`.

Время не стоит на месте, поэтому верный ответ может отличаться от примера в ожидаемом результате. Используйте его как ориентир формата ответа.

SELECT date_part('year', age(birth_date))::integer as age,
       count(user_id) as users_count
FROM   users
GROUP BY age
ORDER BY age

#  как  избавиться от группы с пропущенным значением возраста 

Но почему эта категория вообще возникла? Дело в том, что мы опять столкнулись с `NULL` значениями — на этот раз в колонке `birth_date`. Но `NULL` значение — это тоже какое-то значение, а значит, из соответствующих строк и была образована группа с пропуском.

Давайте избавимся от этих пропусков перед группировкой, добавив в наш запрос оператор `WHERE`. Заодно сделаем наш анализ аудитории чуть более детальным: добавим в группировку пол пользователей.

Напомним, что группировка всегда выполняется после фильтрации, а оператор `WHERE` указывается в запросе перед оператором `GROUP BY`:

## **Задание:**

Вновь разбейте пользователей из таблицы `users` на группы по возрасту (возраст по-прежнему измеряем количеством полных лет), только теперь добавьте в группировку ещё и пол пользователя. Затем посчитайте количество пользователей в каждой половозрастной группе.

Все `NULL` значения в колонке `birth_date` заранее отфильтруйте с помощью `WHERE`.

Колонку с возрастом назовите `age`, а колонку с числом пользователей — `users_count`, имя колонки с полом оставьте без изменений. Преобразуйте значения в колонке с возрастом в формат `INTEGER`, чтобы возраст был выражен целым числом.

Отсортируйте полученную таблицу сначала по колонке с возрастом по возрастанию, затем по колонке с полом — тоже по возрастанию.

Поля в результирующей таблице: `age`, `sex`, `users_count`

---

**Пояснение:**

В результате в каждой возрастной группе должно появиться ещё по две подгруппы с полом. В каждой такой подгруппе необходимо посчитать число пользователей.

Число полных лет из возраста рассчитывайте тем же способом, что и в предыдущих заданиях.

Будьте внимательны: оператор `WHERE` всегда указывается перед оператором `GROUP BY`. Если указать его после, то база данных вернёт ошибку.

SELECT date_part('year', age(birth_date))::integer as age,
       sex,
       count(user_id) as users_count
FROM   users
WHERE  date_part('year', age(birth_date))::integer is not null
GROUP BY age, sex
ORDER BY age, sex

SELECT date_part('year', age(birth_date))::integer as age,
       sex,
       count(user_id) as users_count
FROM   users
WHERE  birth_date is not null
GROUP BY age, sex
ORDER BY age, sex

[[Группировка_данных_content]]