1. Сначала в таблице определяются строки, в которых в указанном в `GROUP BY` столбце есть одинаковые значения.
2. Далее по этим значениям записи объединяются в группы, причём в группе может быть даже одна запись.      
3. После этого с помощью агрегирующих функций над элементами этих групп, как правило, проводятся определённые операции. Например, с помощью `SUM` вычисляется сумма значений в каком-либо столбце в каждой группе:

SELECT column_1, SUM(column_2) AS sum
FROM table
GROUP BY column_1

4. Затем в результирующий запрос попадает по одной уникальной записи из столбца, по которому осуществлялась группировка. При этом напротив каждого такого значения отражается результат агрегации по соответствующей группе, если агрегация проводилась.

А теперь сделаем несколько важных уточнений.

— Во-первых, группировку можно делать сразу по нескольким колонкам:

SELECT column_1, column_2, SUM(column_3) AS sum
FROM table
GROUP BY column_1, column_2

В таком случае количество групп в результирующей таблице будет равно числу уникальных комбинаций значений в нескольких столбцах, указанных в `GROUP BY`. При этом для каждой такой группы будет проведена агрегация значений по колонке, указанной в качества аргумента агрегирующей функции.

---

— Во-вторых, к группам, образовавшимся в результате `GROUP BY`, можно применять сразу несколько агрегирующих функций (в том числе к разным колонкам):

SELECT column_1, SUM(column_2) AS sum, AVG(column_3) AS avg
FROM table
GROUP BY column_1

— В-третьих, после группировки к результатам агрегирующих функций можно применять другие функции. Также над ними можно сразу проводить арифметические операции:

SELECT column_1, ROUND(SUM(column_2), 2) AS rounded_sum
FROM table
GROUP BY column_1


SELECT column_1, SUM(column_2)::DECIMAL / SUM(column_3) * 100 AS share
FROM table
GROUP BY column_1

— В-четвёртых, агрегацию не обязательно проводить по уже имеющимся колонкам — можно сначала применить некоторую функцию в колонке из исходной таблицы, а затем сразу провести агрегацию по новой колонке:

SELECT column_1

SELECT column_1, SUM(some_function(column_2)) AS sum_over_function
FROM table
GROUP BY column_1

— В-пятых, группировку можно делать сразу по новым полям, посчитанным в `SELECT`. При этом допускается использование в `GROUP BY` алиаса колонки, указанного в `SELECT`.

Например, если нам необходимо сгруппировать данные по дням, выделив дату из какой-то колонки, и посчитать сумму некоторых значений в каждый из дней, то можно использовать следующие запросы, которые дадут одинаковый результат:

SELECT DATE(column_1) AS date, SUM(column_2) AS sum
FROM table
GROUP BY DATE(column_1)


SELECT DATE(column_1) AS date, SUM(column_2) AS sum
FROM table
GROUP BY date

**Важно:** несмотря на то, что в соответствии с порядком выполнения операторов блок `SELECT` выполняется после блока `GROUP BY`, в данном случае PostgreSQL позволяет нам немного отойти от правил и упростить процесс написания запроса. в общем случае рекомендуется дублировать расчётное поле в блоке `GROUP BY` и не использовать в нём алиасы колонок из `SELECT`.

— В-шестых, делать агрегацию после группировки не обязательно. Если не указать агрегирующую функцию, то запрос вернёт уникальные значения в столбце (или уникальные комбинации значений в столбцах), т.е. тот же результат, что и оператор `DISTINCT`.

SELECT user_id
FROM user_actions
GROUP BY user_id


SELECT DISTINCT user_id
FROM user_actions

— В-седьмых, при использовании группировки колонки, указанные в `SELECT`, должны находиться и в `GROUP BY`, если они не используются в агрегирующих функциях.

Это обязательное условие, и если оно не будет выполнено, то база данных вернёт ошибку.

SELECT column_1, column_2, SUM(column_3) AS sum
FROM table
GROUP BY column_1, column_2

Обратите внимание, что в обратную сторону указанное выше правило не работает: если мы что-то указали в `GROUP BY`, то это совсем не обязательно указывать в `SELECT`. Иными словами, можно не выводить наименования колонок, по которым осуществляется группировка.

Например, в этом запросе в блоке `SELECT` нет колонки, указанной в `GROUP BY`. Тем не менее такой запрос всё равно сработает:

SELECT SUM(column_2) AS sum
FROM table
GROUP BY column_1

— И наконец, группировка всегда выполняется после фильтрации, т.е. сначала выполняются инструкции в `WHERE` и только потом данные группируются с помощью `GROUP BY`:

SELECT column_1, SUM(column_2) AS sum
FROM table
WHERE column_3 > 0
GROUP BY column_1

Таким образом, порядок записи ключевых слов выглядит так:

1. `SELECT`
2. `FROM`
3. `WHERE`
4. `**GROUP BY**`
5. `ORDER BY`
6. `LIMIT`

В то же время порядок выполнения операторов в запросе следующий:

1. Сначала выполняется оператор `FROM` — происходит выбор нужной таблицы.
2. Далее `WHERE` — отфильтровываются строки, соответствующие условию.
3. Потом `GROUP BY` — строки объединяются в группы и производится агрегация.
4. Затем `SELECT` — отбираются указанные столбцы.
5. Потом `ORDER BY` — производится сортировка результирующей таблицы.
6. И в самом конце `LIMIT` — ограничивается количество выводимых записей.
## **Задание:**

С помощью оператора `GROUP BY` посчитайте количество курьеров мужского и женского пола в таблице `couriers`.

Новую колонку с числом курьеров назовите `couriers_count`.

Результат отсортируйте по этой колонке по возрастанию.

Поля в результирующей таблице: `sex`, `couriers_count`

SELECT sex,
       count(sex) as couriers_count
FROM   couriers
GROUP BY sex
ORDER BY couriers_count

SELECT sex,
       count(courier_id) as couriers_count
FROM   couriers
GROUP BY sex
ORDER BY couriers_count

## **Задание:**

Посчитайте количество созданных и отменённых заказов в таблице `user_actions`.

Новую колонку с числом заказов назовите `orders_count`.

Результат отсортируйте по числу заказов по возрастанию.

Поля в результирующей таблице: `action`, `orders_count`

SELECT action,
       count(order_id) as orders_count
FROM   user_actions
GROUP BY action
ORDER BY orders_count

[[Группировка_данных_content]]