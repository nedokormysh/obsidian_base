

Действительно, тогда мы ничего не знали про подзапросы и в качестве первой даты в функции `AGE` указывали текущую дату, а не последнюю дату в данных. Давайте исправим это досадное недоразумение, ведь теперь у нас для этого есть все необходимые знания.

Но прежде сделаем небольшое, но важное уточнение: подзапросы могут выступать в качестве аргументов функций, т.е. к результату выполнения подзапросов можно применять функции, принимающие на вход какие-то значения. Так, например, подзапросы можно указывать в качестве аргументов функций `CONCAT` или `COALESCE`:

SELECT CONCAT(
              'Начало периода: ', (SELECT MIN(date) FROM table), 
              ' ', 
              'Конец периода: ', (SELECT MAX(date) FROM table)
       )

SELECT COALESCE((SELECT MAX(date) FROM table), NOW())

## **Задание:**

С помощью функции `AGE` и агрегирующей функции снова определите возраст самого молодого курьера мужского пола в таблице `couriers`, но в этот раз при расчётах в качестве первой даты используйте последнюю дату из таблицы `courier_actions`.

Чтобы получить именно дату, перед применением функции `AGE` переведите последнюю дату из таблицы `courier_actions` в формат `DATE`, как мы делали 

Возраст курьера измерьте количеством лет, месяцев и дней и переведите его в тип `VARCHAR`. Полученную колонку со значением возраста назовите `min_age`.

Поле в результирующей таблице: `min_age`

---

**Пояснение:**

В этой задаче результат подзапроса выступает в качестве аргумента функции. Чтобы весь запрос выглядел компактнее, для приведения данных к другому типу можно использовать формат записи с двумя двоеточиями — `::`.

Также обратите внимание, что для получения необходимого результата мы обращаемся к разным таблицам в рамках одного общего запроса.