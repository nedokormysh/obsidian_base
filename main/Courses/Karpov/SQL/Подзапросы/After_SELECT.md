
В начале урока мы отметили, что вложенный запрос может располагаться и после оператора `SELECT`. Однако тогда результатом подзапроса может быть только одно значение — например, результат применения агрегирующей функции к некоторой колонке:

SELECT column_1, (SELECT MAX(column_1) FROM table) AS max_column_1
FROM table


В этом примере из таблицы table будет выбрана колонка column_1, и напротив каждого значения в этой колонке будет выведен результат выполнения вложенного запроса, т.е. максимальное значение в колонке. При этом давать алиас результату подзапроса не обязательно.

По сути эта операция равносильно тому, как если бы мы просто проставили одно и то же значение в отдельном столбце, посчитав его вручную:

SELECT column_1, 1500 AS max_column_1
FROM table

Разница заключается в том, что с помощью подзапроса мы делаем это значение динамическим и избавляем себя от необходимости постоянно его обновлять.

Также результаты подзапросов в блоке `SELECT` можно сразу использовать в вычислениях:

SELECT column_1, (SELECT MAX(column_1) FROM table) - 100 AS column_2
FROM table

На практике подзапрос в `SELECT` может использоваться для того, чтобы сравнить значения в колонке с каким-нибудь одним расчётным значением (из той же или другой таблицы):

SELECT column_1, column_2, column_2 > (SELECT MAX(column_1) FROM table) AS column_3
FROM table

**На заметку:**

На самом деле для того, чтобы в отдельном столбце вывести расчёты с агрегацией по колонкам в той же таблице, не меняя при этом её структуру, чаще используются не подзапросы, а оконные функции — продвинутый функционал, который мы будем рассматривать в конце первого модуля курса.

Сейчас с помощью имеющихся на данный момент знаний мы попробуем решить задачу, не прибегая к продвинутым инструментам. Можете вернуться к этой задаче после прохождения последнего урока и попробовать решить её с помощью оконных функций.

---

## **Задание:**

Используя данные из таблицы `user_actions`, рассчитайте, сколько заказов сделал каждый пользователь и отразите это в столбце `orders_count`.

В отдельном столбце `orders_avg` напротив каждого пользователя укажите среднее число заказов всех пользователей, округлив его до двух знаков после запятой.

Также для каждого пользователя посчитайте отклонение числа заказов от среднего значения. Отклонение считайте так: число заказов «минус» округлённое среднее значение. Колонку с отклонением назовите `orders_diff`.

Результат отсортируйте по возрастанию id пользователя. Добавьте в запрос оператор `LIMIT` и выведите только первые 1000 строк результирующей таблицы.

Поля в результирующей таблице: `user_id`, `orders_count`, `orders_avg`, `orders_diff`
