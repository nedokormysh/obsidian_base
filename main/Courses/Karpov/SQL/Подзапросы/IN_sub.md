
Всё это время мы говорили о подзапросах, возвращающих одно значение в результате применения агрегирующих функций. Теперь рассмотрим случаи, когда подзапрос возвращает несколько значений, и узнаем, как это можно использовать для продвинутой фильтрации данных в таблицах.

Подзапрос, возвращающий несколько значений, может использоваться в блоке `WHERE` совместно с оператором `IN` — например, когда нам нужно проверить, совпадает ли значение в столбце с одним из значений из определённого множества, полученного в результате выполнения подзапроса.

Выглядит это так:

SELECT column_1
FROM table_1
WHERE column_1 IN (SELECT column_2 FROM table_2) 

Сначала подзапрос отберёт все значения в колонке column_2 из таблицы table_2, а затем выберет те записи из таблицы table_1, где в колонке column_1 значение совпадает с одним из значений в колонке column_2, полученной в результате подзапроса. Обратите внимание, что использовать `DISTINCT` в подзапросе необязательно, т.к. на результат основного запроса это никак не повлияет — по большому счёту нет разницы, будут значения в списке уникальными или нет.

При этом запрос выше будет равносилен запросу с табличным выражением:

WITH 
subquery AS (
    SELECT column_2
    FROM table_2
)

SELECT column_1
FROM table_1
WHERE column_1 IN (SELECT * FROM subquery) 


Снова обратите внимание, что при использовании в операторе `WHERE` табличного выражения обратиться просто к его имени нельзя — необходимо предварительно выбрать все его записи, т.е. написать подзапрос. При этом в табличном выражении должен быть всего один столбец, иначе база данных вернёт ошибку.

---

Давайте рассмотрим следующий пример.

Из наших данных довольно легко отобрать отменённые заказы — достаточно указать в `WHERE` нужный фильтр. Но как отобрать созданные, но неотменённые заказы? Это как раз можно сделать с помощью подзапроса или табличного выражения. Давайте попробуем это сделать.

---

## **Задание:**

Из таблицы `user_actions` с помощью подзапроса или табличного выражения отберите все заказы, которые не были отменены пользователями.

Выведите колонку с id этих заказов. Результат запроса отсортируйте по возрастанию id заказа.

Добавьте в запрос оператор `LIMIT` и выведите только первые 1000 строк результирующей таблицы.

Поле в результирующей таблице: `order_id`

SELECT order_id
FROM   user_actions
WHERE  order_id not in (SELECT order_id
                        FROM   user_actions
                        WHERE  action = 'cancel_order')
ORDER BY order_id limit 1000


