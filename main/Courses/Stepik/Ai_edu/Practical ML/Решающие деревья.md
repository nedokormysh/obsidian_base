
Решающие деревья - это деревья (как математический объект), то есть ориентированные графы с _корнем_ и несколькими концевыми вершинами (_листьями_).

При помощи решающих деревьев можно описать довольно много алгоритмов. Часто схема работы экспертов и различных программ описана именно деревом.

# **Терминология**

- **Корень дерева** - вершина, из которой исходят ребра, но не входит ни одно ребро
- **Ребра -** отрезки, исходящие из вершин дерева
- **Предикат -** условие, которое проверяется в вершине дерева
- **Лист** - концевая вершина дерева; в листьях дерева стоят предсказания модели

Деревья бывают разные, но для целей _Data Science_ чаще всего используются _бинарные решающие деревья_, то есть деревья, из каждой внутренней (не листовой) вершины исходит ровно две ветки.

**Предикаты**

Предикаты, то есть условия, которые мы проверяем в вершинах дерева, могут быть разными. Но в классических решающих деревьях предикаты очень простые: Предикат имеет вид **"признак > порога"**, то есть в каждой вершине используется ровно один признак и он сравнивается с некоторым пороговым значением.

**Жадный алгоритм**

Деревья на практике строятся пошагово, то есть сначала подбирается первый предикат, который дает наилучшее качество разбиения. Затем второй, третий и так далее. Такой алгоритм построения дерева называется _жадным_.

Жадный алгоритм - не самый оптимальный. Гораздо лучше было бы перебирать всевозможные готовые деревья и выбирать из них наилучшее, но это очень сложная задача (NP-полная) и за разумное время её решить невозможно.

Важной особенностью деревьев - **_они склонны к сильному переобучению!_**
Поэтому чтобы дерево не переобучалось, существуют подходы к ограничению сложности его структуры: ограничение глубины дерева, ограничения на количество объектов в промежуточных вершинах и в листьях дерева и другие.

[[Practical_ML_content]]